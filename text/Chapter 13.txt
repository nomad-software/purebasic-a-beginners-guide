13

Beyond The Basics

This chapter contains a mish-mash of topics because I felt all these subjects needed to be explained but each one really didn’t warrant a full chapter. These things are not essential to know if you want to write PureBasic programs but are for programmers who want to increase their knowledge of the more advanced features of the PureBasic language.

Topics covered in this chapter include; Compiler Directives and how to control the compiler using code, Advanced Compiler Options to get more from the PureBasic compiler, How to pass Command Line Arguments to you program for writing command line tools, How PureBasic stores numeric data types, What Pointers are and how to use them, What Threads are and how to use them, What Dynamically Linked Libraries are and how to create them and How to use the Window Application Programming Interface natively in PureBasic.

Compiler Directives And Functions

Compiler directives are commands that control the PureBasic compiler during compile time. As such, these directives allow you to have total control over what parts of your source code are compiled and allow you to retrieve information from the compiler. Compiler directives only have an effect during compile time, where they are parsed and acted on. They cannot be utilized while your program is actually running.

Compiler functions are different from directives as these are commands which enable you to gather information about something that has already been compiled (usually a data type). Unlike directives, compiler functions can be utilized while the program is running.

Earlier on in this book you have already seen examples of compiler directives and compiler functions but you might not have noticed, for example, I demonstrated the ‘EnableExplicit’ command in Chapter 8 (How To Minimize And Handle Errors). This compiler directive switches the compiler to explicit mode and makes sure all variables are explicitly declared, making sure the scope and type of each new variable is defined. You have also seen the ‘SizeOf()’ and ‘OffsetOf()’ commands in Chapter 5. These compiler functions gather information from compiled structures and interfaces, such as the size in Bytes of a particular structure in memory or the offset of where a particular field is within a structure or interface.

There are a few more directives and functions to add to this list, but before I can continue to explain these any further, I’ll need to explain the built-in reserved compiler constants that they nearly all use.

Reserved Compiler Constants
These built-in reserved constants are just like any other constant, but what is different is that their values largely depend on the current state of the compiler. All these constants can be tested at compile time to make decisions on how to proceed with the compilation and some constants even provide information about the compiling process itself. Here is a full list of the reserved compiler constants and what information you may get from them.

‘#PB_Compiler_OS’
This is a special constant that is assigned a value depending on what platform the compiler is running on. It also has some associated constants to help you determine what it’s value may mean. For example, if the ‘#PB_Compiler_OS’ constant has a value equal to any one of either ‘#PB_OS_Windows’, ‘#PB_OS_Linux’, ‘#PB_OS_AmigaOS’ or ‘#PB_OS_MacOS’ then the compiler is running on that particular platform.

‘#PB_Compiler_Date’
This constant’s value contains a date in numeric form, which is the date of when your program was compiled. This value is encoded in the PureBasic date format to integrate nicely with the commands in the ‘Date’ library (Helpfile:Reference Manual->General Libraries->Date).

‘#PB_Compiler_File’
This constant’s value is a String that contains the full path and name of the file (*.pb) being compiled.

‘#PB_Compiler_Line’
This constant’s value is the line number of the current file which is being compiled.

‘#PB_Compiler_Version’
This constant’s value contains a floating point number which is the version of the compiler being used to compile the program.

‘#PB_Compiler_Home’
This constant’s value is a String containing the full path of PureBasic’s installation folder on your computer.

‘#PB_Compiler_Debugger’
This constant can have one of two values. If its value is equal to ‘#True’ then the debugger was enabled  before the program was compiled. If its value is equal to ‘#False’ then the debugger was disabled before compilation.
‘#PB_Compiler_Thread’
This constant can have one of two values. If its value is equal to ‘#True’ then the compiler was switched to thread-safe mode before compilation. If its value is equal to ‘#False’ then the thread-safe compiler mode wasn’t used.

‘#PB_Compiler_Unicode’
This constant can have one of two values. If its value is equal to ‘#True’ then the compiler was switched to unicode mode before compilation. If its value is equal to ‘#False’ then the unicode compiler mode wasn’t used.

All these reserved compiler constants can be used as normal in statements and expressions, in fact you can use them anywhere where you would use a normal constant. However, most of these compiler constants are only really useful when they are used with the following directives.

The ‘CompilerIf’ Directive
If you understand how to use ‘If’ statements in PureBasic you will understand how to use ‘CompilerIf’s. A ‘CompilerIf’ is a statement that acts exactly like any other ‘If’ statement but which is never actually compiled. It’s basically a compiler version of an ‘If’ statement.

Unlike a normal ‘If’, a ‘CompilerIf’ decides which piece of code to compile based on the result of a constant expression (no variables allowed). In contrast, a normal ‘If’ decides which piece of (already compiled) code to run based on a variable expression.

Let me show you an example of one of the most common uses of a ‘CompilerIf’:

CompilerIf #PB_Compiler_OS = #PB_OS_Windows
	MessageRequester("Info", "This compiler is running on Microsoft Windows")
CompilerElse
	MessageRequester("Info", "This compiler is NOT running on Microsoft Windows")
CompilerEndIf

Here the ‘CompilerIf’ tests this constant expression; ‘#PB_Compiler_OS = #PB_OS_Windows’. If this expression equals true then we know that this piece of code is being compiled on a computer running Microsoft Windows. If it equals false then it isn’t, it’s as simple as that. This seems pretty straightforward but what’s clever about using ‘CompilerIf’s is that whichever branch the ‘CompilerIf’ statement takes, it will only compile that piece of code. With that in mind, if we compiled this example on a Microsoft Windows computer, then the line:

MessageRequester("Info", "This compiler is NOT running on Microsoft Windows")

Will never get compiled and therefore never be included in the program’s executable file.

A ‘CompilerIf’ statement consists of three commands, all of which are demonstrated in the above example. The ‘CompilerElse’ component, which is similar to a standard ‘Else’, is entirely optional but the whole statement must end with ‘CompilerEndIf’.

Some programmers use ‘CompilerIf’s to limit the functionality of a program especially if it’s compiled as a trial version. For example, if I write a useful program and want to give my users a demo to try before they buy, and I’m afraid that some might attempt to crack it to remove any limitations. I could code my program like this:

#DEMO = #True

CompilerIf #DEMO

	;Demo code
	MessageRequester("Info", "This is a demo, You must buy the full version.")

CompilerElse

	;Full version code
	Procedure.d MyPI()
		ProcedureReturn ACos(-1)
	EndProcedure

	Test.s = "This is the full version." + #LF$ + #LF$
	Test.s + "The value of Pi is: " + StrD(MyPI(), 16)
	MessageRequester("Info", Test)

CompilerEndIf

Just simply changing the value of the constant ‘#DEMO’ will now force the compiler to compile different versions of the source code. This is useful as it can prevent cracking of your demo programs because they simply will not contain the code contained inside the full version. Try changing the value of the ‘#DEMO’ constant to ‘#False’ to compile the full version of this program.

The ‘CompilerSelect’ Directive
The ‘CompilerSelect’ statement is a compiler version of the popular ‘Select’ statement. This means that multiple sections of source code can be compiled depending on the different values of a selected constant. Similar to a ‘CompilerIf’, ‘CompilerSelect’s can only test constant values, this is again because the test is done at compile time instead of runtime. Here’s another operating system test done using a ‘CompilerSelect’:

CompilerSelect #PB_Compiler_OS
	
	CompilerCase #PB_OS_Windows
		;Windows specific code
		MessageRequester("Info", "This is being compiled on Microsoft Windows.")
	
	CompilerCase #PB_OS_Linux
		;Linux specific code
		MessageRequester("Info", "This is being compiled on Linux.")
	
	CompilerCase #PB_OS_MacOS
		;MacOS specific code
		MessageRequester("Info", "This is being compiled on MacOS X")

	CompilerCase #PB_OS_AmigaOS
		;AmigaOS specific code
		MessageRequester("Info", "This is being compiled on Amiga OS.")
	
CompilerEndSelect

Using something like this, it’s possible to customize your program to exhibit different behavior based on what operating system it’s compiled for. Your program might also use commands from a particular operating systems API, and because commands like that are not cross-platform, you might use a ‘CompilerSelect’ to use other operating system’s APIs to produce the same result on all platforms.

PureBasic provides support for several keywords to give a ‘CompilerSelect’ the same functionality as a normal ‘Select’ statement. These keywords are, ‘CompilerSelect’, ‘CompilerCase’, ‘CompilerDefault’ and ‘CompilerEndSelect’. You have seen three of these commands in the ‘CompilerSelect’ example above. The forth one, ‘CompilerDefault’ is used as a fallback case keyword to handle a default state just incase the ‘CompilerCase’ commands don’t return true, like this:

CompilerSelect #PB_Compiler_OS

	CompilerCase #PB_OS_AmigaOS
		;AmigaOS specific code
		MessageRequester("Error", "This source code does not support Amiga OS.")
		
	CompilerDefault
		;This code will compile on all other operating systems.
		MessageRequester("Info", "This is code will compile fine on this OS.")
	
CompilerEndSelect

In this example I’ve thrown up an error if someone tries to compile this code on AmigaOS but for all other operating systems (handled by the ‘CompilerDefault’ keyword) it runs fine.

Although my examples for the ‘CompilerIf’ and ‘CompilerSelect’ mainly use the ‘#PB_Compiler_OS’ constants, you must remember that any constants, compiler reserved or not, can be tested by them. This is so you can customize the compiling process using PureBasic code as much as you see fit.

The ‘CompilerError’ Directive
This directive can be used by itself or within other compiler directives, such as ‘CompilerIf’ or ‘CompilerSelect’ to raise a compiler error, complete with helpful text. This is handy when you want to stop the compilation process and give the user a graceful compiler error message. Here is the above ‘CompilerSelect’ example translated to use a real compiler error message:


CompilerSelect #PB_Compiler_OS

	CompilerCase #PB_OS_MacOS
		CompilerError "This source code does not support MacOS."

	CompilerDefault
		MessageRequester("Info", "This is code will compile fine on this OS.")

CompilerEndSelect

Looking at this example, you can see that the ‘CompilerError’ directive does not use brackets to enclose any parameters like a normal command. Instead we simply use the ‘CompilerError’ directive with a literal String following it. This String will be the error text that is displayed when the compiler error is thrown. When the compiler encounters an ‘CompilerError’ directive, the compilation is stopped and the error text is presented. 

The ‘Subsystem()’ Compiler Function
To explain this compiler function I must first explain subsystems in general, and how they relate to PureBasic. Subsystems are an easy concept to grasp, basically, if you are not happy with the functionality of any of PureBasic ‘s built-in commands you can override them with your own versions, these new versions are contained within a subsystem.

If you take a look inside the PureBasic installation folder, you will see a folder called ‘PureLibraries’, this folder contains library files which contain PureBasic’s built-in commands. These library files are the ones that are replaced when a subsystem is used. When I say replaced, I don’t mean actually deleted or copied over. A subsystem library merely takes priority over standard libraries.

To create a subsystem you must first rewrite and compile a PureBasic library (there is more information regarding this in the PureBasic ‘Library SDK’ folder). This new library must contain all commands of the original library and all these commands must be named in exactly the same way as the originals. You must then make sure that the name of the newly compiled library matches the name of the library you want it to replace.

Once you have done this, it should be an almost identical copy of the original library, apart from the functionality of the commands it contains (you can write these to have any functionality you wish). To install this library as a subsystem, so you can use it during compilation, you need to create a new folder within the ‘SubSystems’ folder in your PureBasic installation directory. The name you give this new folder will be the name of your new subsystem. Inside this new subsystem folder you now must have a folder called ‘PureLibraries’, and this is where you put your replacement libraries. So the directory structure of these folders will looking something like this:

‘..\PureBasic\SubSystems\YourSubSystem\PureLibraries\YourNewLibrary’

To make PureBasic use your new subsystem, you must add a subsystem flag to the compiler so it uses the libraries from your subsystem and not those from the standard ‘PureLibraries’ folder. To do this open the ‘Compiler Options’ window (Menu:Compiler->Compiler Options...) and type the subsystem folder name (the one that you created in the ‘SubSystems’ folder) into the ‘Library Subsystem:’ field, then click ‘OK’. When your program is next compiled, the compiler will scan the ‘SubSystems’ and ‘PureLibraries’ folders looking for libraries, if it finds that these two folders contain identically named libraries, the compiler will always choose the specified subsystem over the standard one, therefore replacing the original.

There is already an example of a subsystem in the ‘SubSystems’ directory. If you look in there, you will find a folder called ‘OpenGL’, inside which is a ‘PureLibraries’ folder, and inside that, there are replacement libraries for ‘Screen’, ‘Sprite’ and ‘Sprite3D’. These are the libraries this subsystem will replace if this subsystem is used. Once activated via a compiler flag, this subsystem will use OpenGL for 2D graphics instead of DirectX.

Now, as mentioned earlier I will explain the ‘Subsystem()’ compiler function.

During compilation, the ‘Subsystem()’ compiler function lets you know if a particular subsystem has been activated using a compiler flag. The syntax is easy enough to understand, For example, if I had enabled the ‘OpenGL’ subsystem the following debug message would be displayed:

If Subsystem("OpenGL")
	Debug "The OpenGL subsystem is being used."
EndIf

The ‘Subsystem()’ compiler function takes one parameter, this is a literal String of the subsystem you want to test for, (variables cannot be used here). If this subsystem has been activated and is being used to compile this program, then the ‘Subsystem()’ compiler function will return true.

The ‘Defined()’ Compiler Function
Sometimes when coding software you need to test wether a particular data object has been defined. This is achieved by using the ‘Defined()’ compiler function. This function takes two parameters, the first is a data object to test for, and the second is the data type of that object. If this particular object has been defined, then the ‘Defined()’ compiler function will return true. The value of the object being tested doesn’t matter, only that it has been defined. The data objects that can be tested are constants, variables, arrays, linked lists, structures and interfaces.

When using the ‘Defined()’ compiler function, the first parameter must only be the name of the data object to test and must not contain any of the usual prefixes or suffixes that are usually used for that object. For example, constant names must not contain the ‘#’ character and array and linked list names must not contain brackets. For the second parameter, where you pass the type of the object you are testing, you can use built-in constants, here is the full list of what is available:

‘#PB_Constant’
‘#PB_Variable’
‘#PB_Array’
‘#PB_LinkedList’
‘#PB_Structure’
‘#PB_Interface’

I’ve made this command sound like it’s quite complicated to use, so I better dismiss that with a simple example of how easy it really is. This example tests if the variable; ‘Name.s’ has been defined, if not, it defines it:

Global Name.s = "Name 1"

If Not Defined(Name, #PB_Variable)
	;This will only define this variable if it hasn't been defined before
	Global Name.s = "Name 2"
EndIf

Debug Name

You can test this piece of code by commenting out the first line. If you do this, the variable definition now takes place inside the ‘If’ statement and the String variable’s value will now be ‘Name 2’. Code like this is invaluable for large projects, where you may be including a lot of source code files into a main one and you need to test if something important has been defined before. If not, then define it.

Advanced Compiler Options

When using PureBasic you may need to change modes on the compiler for a particular program or you may need to have the compiler output specific information. To be able to do this, PureBasic offers several compiler options for you to use. You can enable or disable most of these options visually in the IDE from within the ‘Compiler Options’ window (Menu:Compiler->Compiler Options...). To gain access to all supported compiler options, you have to call the compiler using a shell command and pass the options as parameters.

So what is a command line interface anyway? Well, it’s a small program that usually comes with your operating system (sometimes called a Shell Interface), that allows you to navigate your computer’s hard drive or start programs and control computer functions by typing in recognized text commands. It does not have any other user interface other than text input. There are numerous command line interface programs available, and these seem to be some of the most popular:

	‘CLI’ on AmigaOS
	‘Command Prompt’ on Microsoft Window XP
	‘BASH’ on Linux
	‘Terminal’ on MacOS X

For these command line interfaces to work correctly with PureBasic, you may need to add the full directory path to the compiler to your ‘PATH’ environment variable. This is so the command line interface always knows where the compiler is located. Using an environment variable like this will negate the need to type in the full path of the compiler when using it in a shell command. Using a command line interface, in my opinion, is not very user friendly, but it’s the only way to use some of the more advanced features of the PureBasic compiler. Saying that though, sometimes having a compiler that you can use on the command line is useful, especially if you want to use your own code editor, then you can set it up as an external tool.

Using The Compiler On The Command Line
Using the compiler on the command line is simple enough, you just have to make sure you pass the optional parameters correctly. The actual compiler command itself must always start with the name of the PureBasic compiler followed by any parameters that are required. The only mandatory parameter is a file to pass to the compiler for processing.

Using the command line compiler in its simplest form to produce an executable file from a PureBasic file, doesn’t need any optional parameters to be passed to it, but it does need the name of a ‘*.pb’ file. Open a command line interface window, type this in it and hit return:

PBCompiler MyProgram.pb

If your ‘PATH’ environment variable is configured correctly, this command will start the PureBasic compiler and pass the ‘MyProgram.pb’ file to it. The compiler will create a temporary executable file in the same directory as the compiler and launch that program, in the same way as if you had hit the ‘Compile/Run’ button in the IDE. This is probably the simplest way of compiling a program using the command line.

If you want to compile a program to an executable file which has a user defined name, and want that file to appear in the same directory as the source code file, then you can use this shell command:

PBCompiler MyProgram.pb /exe "MyProgram.exe"

This would compile the ‘MyProgram.pb’ file and create an executable file from it. This compiled executable file will be called ‘MyProgram.exe’ and will be placed in the same directory as the specified ‘*.pb’ file. Notice in this command we are using a new compiler option; ‘/exe’. This tells the compiler that we want a properly named executable file. The String after this compiler option is what that file should be called. All command line compiler options start with a forward slash ‘/’ like this. These two examples are fairly easy to understand, but these actual commands are seldom used in practice. People prefer instead to use the PureBasic IDE to perform simple compilations. These two are useful to know though, especially if you want to set up another code editor.

When using compiler options on the command line, it’s also important to understand that many options can be used at the same time. For example, if I wanted to compile a ‘*.pb’ file to an executable and assign an icon to it, I would use a shell command like this:

PBCompiler MyProgram.pb /exe "MyProgram.exe" /icon ".\icons\MyIcon.ico"

The compiler recognizes that the String after the ‘/exe’ option is what the executable file should be called and the String after the ‘/icon’ option is the icon file that should be applied to this executable. All command line compiler options must always be separated by spaces.

PureBasic Command Line Compiler Options
What follows now is a complete list of all PureBasic’s command line compiler options, including an explanation of each one and a small example of its usage. Remember, most of these options can be enabled visually in the IDE, using a checkbox or a drop-down menu in the ‘Compiler Options’ window. This enables you to control the compiler’s behavior more easily. All these command line options are also completely case insensitive, so you can enter them in upper or lowercase, it’s entirely up to you.

/?
This is a command line only option which displays a helpful page detailing all available PureBasic command line compiler options. The help page is printed to the shell interface window. This compiler option also overrides any others used in the same shell command.

PBCompiler /?

/Commented
This is another command line only option which creates a commented Assembly file in the ‘PureBasic\Compilers’ folder called ‘PureBasic.asm’ along with any executable file output. This file is the raw output of the PureBasic compiler and contains the raw compiler generated assembly source code of the ‘*.pb’ file. This file can be re-compiled into an executable file, using the ‘/reasm’ compiler option, even if modifications are made to it.

PBCompiler MyProgram.pb /commented

/Console
This compiler option enables you to compile a true console application. Here’s a simple example:

PBCompiler MyProgram.pb /exe "MyProgram.exe" /console

For more information regarding console applications, please refer to Chapter 9 (Console Programs).

/Constant (Name=Value)
This is another command line only option which enables you to define a constant dynamically on the command line. This can be useful if, for example, you code a program that changes its functionality depending on the value of that constant. For example: ‘DEMO=1’ or ‘DEMO=0’.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /constant MY_STRING="Hello World"

As you can see from this example, when defining a constant on the command line you must not use the ‘#’ character to prefix the constant name and there must be no space around the equals sign (‘=’). Also, if you are defining a String constant, I would advise enclosing it within double quotation marks as in my example. This is not one hundred percent necessary because the compiler tries to automatically convert it into a String if they are missing, but it may get confused and error if that String contains spaces. For safety sake, use double quotes for Strings.

/Debugger
If this compiler option is used by itself, the standalone (GUI) debugger is enabled to debug the resulting temporary executable file. If this option is used with the ‘/exe’ option, the console debugger is embedded into the resulting executable file. The console debugger will then display a console window along with the launched executable file to allow command line based debugging of that program. Here’s these two examples:

PBCompiler MyProgram.pb /debugger
PBCompiler MyProgram.pb /exe "MyProgram.exe" /debugger

/DLL
This compiler option allows you to create a DLL (dynamically linked library) file from your PureBasic source code. If this option is used during compilation, the resulting DLL file is created within the ‘PureBasic\Compilers’ folder called ‘PureBasic.dll’. This file can then be renamed as you see fit. As a byproduct of creating a DLL like this, a static library file called ‘PureBasic.lib’ and an export file called ‘PureBasic.exp’ is also created in the same folder.

PBCompiler MyProgram.pb /dll

PureBasic source code files that are used to create DLL’s are usually composed of procedures only. Some of these procedure are specially named to give you extra functionality within your compiled library. Read further on in this chapter for more information on DLL’s.

/DynamicCpu
This command line option is almost equivalent to specifying all the options; ‘/mmx’, ‘/3dnow’, ‘/sse’ and ‘/sse2’ in one go. If your program’s source code contains ASM routines that support all these processor extensions and you use the ‘/dynamiccpu’ compiler option then the resulting executable file will contain all of the processor specific code. What’s happens when this executable is run, is it looks at the processor type of the system it’s being run on and chooses between the compiled routines to select the one that matches that particular processor’s architecture. Meaning that it dynamically uses different code contained within it for different processors. This could make the executable file larger than usual because it may contain many versions of the same routine, but it can make the program run faster because those different routines can contain specific processor optimized code. 

PBCompiler MyProgram.pb /exe "MyProgram.exe" /dynamiccpu

/Exe "FileName"
This compiler option is pretty straightforward, the String after the ‘/exe’ part is the name that the executable file will be compiled as. A String specifying the executable name must always follow the ‘/exe’ part and must always be contained within double quotation marks, otherwise you may get unexpected results. Also when compiling a program like this, the generated executable file will be placed in the same directory as the source code used to compile it.

PBCompiler MyProgram.pb /exe "MyProgram.exe"

/Icon "IconName"
This compiler option lets you specify an icon on your hard drive that you would like your executable to use. The String after the ‘/icon’ part must be defined and must be enclosed in double quotation marks, as this is the location on your hard drive of where the desired icon file is located. The String containing the location of the icon file can be a relative String if needed, as in this example:

PBCompiler MyProgram.pb /exe "MyProgram.exe" /icon ".\icons\MyIcon.ico"
/IgnoreResident "FileName"

This is a command line only option which enables you to stop an installed resident file from loading during compilation. This is handy if you want to re-compile a resident file that is already installed in the ‘PureBasic\Residents’ folder. If the installed resident file is not ignored and you are re-compiling that file again, you may get ‘Already defined’ errors.

PBCompiler MyProg.pb /resident "MyResid.res" /ignoreresident "MyResid.res"
PBCompiler MyProgram.pb /exe "MyProgram.exe" /ignoreresident "MyResid.res"

The first line shows an example of compiling a resident file while ignoring the previously installed version. The second line is an example of what you may need to do if you are re-defining constants or structures in your program that are already present in an installed resident file.

/InlineAsm
This compiler option enables inline assembly programming within your ‘*.pb’ file. In other words if you have used any assembly language commands within your PureBasic source code, you should enable this feature so the assembly commands are passed correctly to the PureBasic compiler.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /inlineasm

/LineNumbering
This compiler option adds support for internal line numbering of commands within your executable file. This is useful for third party debugging tools or if you are using the built-in ‘OnError’ library.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /linenumbering

Be aware that if you are using line numbering for your executable, it could slow down the speed with which it runs, because you are adding slightly more ‘overhead’ to the executable than usual.

/Linker "FileName"
This is a command line only option which enables you to pass a file straight to the linker which can contain linker commands.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /linker "MyLinkerCommands.txt"

/MMX, /3DNow, /SSE And /SSE2
These four compiler options create very processor specific executables depending on which option is used. Only one of these options can be used at a time, as they tailor the executable file to only include routines that specifically run on processors that support such extensions. If you have created many routines using ASM that support all processor extensions, only the ones which match the compiler option will be used in the final executable. For example, if you create an executable that uses the ‘/mmx’ compiler option, only the MMX routines used in the source code will be used for the final executable and that executable will only run on processor that support the MMX extensions.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /mmx
PBCompiler MyProgram.pb /exe "MyProgram.exe" /3dnow
PBCompiler MyProgram.pb /exe "MyProgram.exe" /sse

PBCompiler MyProgram.pb /exe "MyProgram.exe" /sse2

/Quiet
This is a command line only option which suppresses all unnecessary text output from the command line compiler. This is handy when you want to use the compiler as an external tool from another code editor, etc.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /quiet

/ReAsm
This is a command line only option which enables you to re-assemble and compile a previously exported, commented ‘*.asm’ file. These commented ‘*.asm’ files are created using the ‘/commented’ compiler option.

PBCompiler PureBasic.asm /reasm

When using this command, the ‘*.asm’ file to be re-assembled must be in the ‘PureBasic\Compilers’ folder, otherwise a compiler error will occur.

/Resident "FileName"
This is a command line only option which enables you to create a resident file from a standard ‘*.pb’ file. Resident files are usually composed of constant and structure definitions only.

PBCompiler MyProgram.pb /resident "MyResident.res"

A String enclosed in double quotation marks must be defined after the ‘/resident’ part of this compiler option, as this defines the name of the new resident file. If this String is missing or not enclosed in double quotes, then a compiler error will occur. Using this compiler option will create a resident file inside the same directory as the source code file.

/Resource "FileName"
This compiler option is for Microsoft Windows only as it appends a Windows resource file to the compiled DLL or executable file. A String enclosed in double quotation marks must follow the ‘/resource’ part of this compiler option which specifies the resource file to add. Only one resource file may be added but this file can contain references to other resource files if needed. The resource file must not be a compiled resource either, but be an ASCII file containing directives.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /resource "MyResource.rc"

/Standby
This command line option is used by the IDE to load the compiler into memory to wait for commands to be passed to it. This is not a command that normal users would usually use because documentation is very scarce regarding how to interface with the compiler once it’s loaded into memory.

/Subsystem "SubsystemName"
This compiler option enables you to specify a subsystem to use for the compilation of your program. I’ve given subsystems a full description a little earlier in this chapter, so I’ll not repeat myself here. By default there are a few built-in subsystems which you can choose from when compiling your program, these are:

Windows:
	PBCompiler MyProgram.pb /exe "MyProgram.exe" /subsystem "NT4"
	PBCompiler MyProgram.pb /exe "MyProgram.exe" /subsystem "OpenGL"

Linux:
	PBCompiler MyProgram.pb /exe "MyProgram.exe" /subsystem "GTK2"

MacOS X:
	PBCompiler MyProgram.pb /exe "MyProgram.exe" /subsystem "GTK"
	PBCompiler MyProgram.pb /exe "MyProgram.exe" /subsystem "GTK2"

As you can see from these examples, after the ‘/subsystem’ part of this compiler option you must specify a subsystem name, enclosed within double quotation marks.

/Thread
This compiler option will enable thread-safety for the compiled executable file. This option should be used if you are compiling a program that makes use of threads. One thing to remember when using this command is that the resulting executable file may run slightly slower than a non-threadsafe one. This is because of the extra ‘overhead’ needed to make the executable thread safe.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /thread

More information about threads can be found later in this chapter.

/Unicode
This compiler option will enable unicode support for your compiled executable. Unicode is a character encoding scheme using 16 bits (2 Bytes) per character to allow all characters of all major world languages, living and dead, to be encoded in a single character set. Using this compiler option means that all PureBasic commands used and the internal String management will be fully unicode compatible.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /unicode

/Version
This is a command line only option, and its only function is to print the version of the PureBasic compiler used in the command line interface window. This compiler option overrides any others used in the same shell command.

PBCompiler /version

/XP
This compiler option is for Microsoft Windows XP only. It adds Windows XP skin support to your executables, to make them show themed gadgets and windows correctly when a theme is used for the Windows GUI.

PBCompiler MyProgram.pb /exe "MyProgram.exe" /xp

Parsing Command Line Parameters

Sometimes when developing programs using PureBasic you may want to create command line tools that accept certain parameters when being launched using a shell command. This is a similar way to how the PureBasic compiler works. The program is started and parameters are passed to it, the values of these parameters determine what function the program performs. In this section I will show you how to parse these types of parameters that are passed to your program.

Explaining Parameters?
When passing parameters (sometimes called arguments) to command line programs, you need to keep in mind how they are passed and what actually constitutes a parameter. For example, if we take this compiler example from earlier on in this chapter:

PBCompiler MyProgram.pb /exe "MyProgram.exe"

This shell command instructs the operating system to launch the ‘PBCompiler’ program and pass three parameters, (‘MyProgram.pb’, ‘/exe’ and ‘"MyProgram.exe"’). Even though we are only using one compiler option after the ‘*.pb’ file name (which is the first parameter), that option consists of two further parameters.

When passing parameters to programs like this, the program makes a decision about how many parameters are passed based on how many spaces it sees after the program name. If you need to have spaces within a single parameter, then you must enclose that parameter in double quotation marks. For example, all these shell commands would pass two parameters to the program called ‘MyProgram’:

MyProgram /a 105
MyProgram /play /now
MyProgram /play "Me And My Shadow"
MyProgram "Put It In The" "Back"

As you can see from these examples, parameters can be either numbers or Strings, but when they are passed into your program they are all automatically converted into Strings. If you are enclosing parameters in double quotation marks when passing them (especially for parameters with spaces) you should keep in mind that these quotation marks are stripped out before the String is actually passed, so you are only passing the String inside them, not the quotes.

Reading Passed Parameters From Inside Your Program
When parameters are passed to your program from a shell command, they are stored internally for you to read in your program when you see fit. By calling the ‘ProgramParameter()’ command you can return one parameter at a time from this internal list. When all parameters have been returned by the ‘ProgramParameter()’ command, it then returns an empty String. Here is an example program showing how to list all parameters that are passed to a program:

NumberOfParameters.l = CountProgramParameters()
Text.s = "List of parameters passed:" + #LF$ + #LF$

If NumberOfParameters > 0
	For x.l = 1 To NumberOfParameters
		Text.s + ProgramParameter() + #LF$
	Next x
Else
	Text.s + "None"
EndIf

MessageRequester("Info", Text)

The first line of this example uses the ‘CountProgramParameters()’ command, this returns the exact number of valid parameters that was passed to your program. After this command has been called, I then use a ‘For’ loop to call the ‘ProgramParameter()’ command over and over again to return all parameters. If I compile this piece of code to an executable file and called it ‘ListParameters.exe’, I could then pass some parameters to it using a shell command, like this:

ListParameters /one /two /three

These parameters are just made up for this example so you can use any you like, I’ve used a forward slash to prefix my parameters as this seems to be the norm for console programs I use. Once this command has been entered and the program has been launched. The value stored in the ‘NumberOfParameters’ variable would be ‘3’ and each time the program calls the ‘ProgramParameter()’ command, each one of these parameters will be returned in sequence. The first time it’s used, the ‘ProgramParameter()’ command will return ‘/one’, the second time it’s used it will return ‘/two’ and the third time ‘/three’ is returned. If I called the ‘ProgramParameter()’ command a forth time, it would return an empty String.

<<Box 26>>

Making Decisions Based On Parameters If you are using command line parameters to control the functionality or output of your program, you will need it to perform different actions depending on the values of those passed parameters. Sometimes you will need your program to do something completely different if a particular parameter is passed. Making decisions based on what parameters have been passed is not as hard as you may think, you just use regular ‘If’ and ‘Select’ statements to test the values of the parameters.

This next example demonstrates this approach, testing to see if one or more of the parameters passed is either, ‘Mouse’, ‘Cat’ or ‘Dog’. Try passing one or two of these parameters to this program to see the output:

;Count parameters
NumberOfParameters.l = CountProgramParameters()

;Add all command line parameters to a linked list
Global NewList Parameters.s()
If NumberOfParameters > 0
	For x.l = 1 To NumberOfParameters
		AddElement(Parameters())
		Parameters() = UCase(ProgramParameter())
	Next x
EndIf

;Check to see if a particular parameter was passed
Procedure ParameterPassed(Parameter.s)
	ForEach Parameters()
		If Parameter = Parameters()
			ProcedureReturn #True
		EndIf
	Next 
	ProcedureReturn #False
EndProcedure

;Check to see if the parameter 'Mouse' was passed
If ParameterPassed("MOUSE")
	MessageRequester("Info", "'Mouse' was specified as a parameter.")
EndIf
;Check to see if the parameter 'Cat' was passed
If ParameterPassed("CAT")
	MessageRequester("Info", "'Cat' was specified as a parameter.")
EndIf
;Check to see if the parameter 'Dog' was passed
If ParameterPassed("DOG")
	MessageRequester("Info", "'Dog' was specified as a parameter.")
EndIf

If you look closely at this example I’m using the ‘UCase()’ command (Helpfile:Reference Manual->General Libraries->String->UCase) to convert all passed parameters to uppercase lettering. This so I can perform String comparisons on the parameters without worrying about its case. If you do this in your programs, then you can just use uppercase String comparisons, as shown in the ‘If’ statements. This is good practice because it doesn’t matter how the user enters parameters (uppercase, lowercase, mixed case) they will always be converted to uppercase before the ‘If’ comparison.

Giving your programs command line support by utilizing parameters in this way may seem an old fashioned way of doing things, and to be honest, it is. However, giving your users the potential to use your application or tool from the command line will get more people using it and will give the program more versatility. It’s definitely something to think about when creating a piece of software.

A Closer Look At Numeric Data Types

Numeric data types allow you to store numbers in several different formats and each type allows you to use slightly different amounts of memory to store those numbers. This doesn’t sound like such a big deal but the amount of memory a numeric type uses strictly defines its numerical limit. If you look back in Chapter 2 at Fig.2, you will see a diagram detailing all PureBasic’s numerical type limits. These limits are imposed by the finite number of bits contained within the memory that these data types allocate. For example, if you look at the Byte data type (.b) you will see that it uses one Byte of memory, which consists of eight binary digits or ‘bits’. These bits can only be manipulated in a finite amount of ways to express numbers. In fact, eight bits can only be ordered into two hundred and fifty six (256) unique patterns, with each bit being either ‘1’ or ‘0’. This means only two hundred and fifty six unique numbers are capable of being expressed by an eight bit binary number (Byte).

In this section I will explain to you, how numbers are stored in memory and how binary numbers are actually calculated. Hopefully this will give you a little more insight into the inner workings of not only PureBasic but of computers in general.

When dealing with numbers in computer languages there needs to be made a clear distinction between integers and floating point numbers. Integers are numbers which can be positive or negative but do not contain a decimal point. Floating point numbers on the other hand can be positive or negative but always contain a decimal point. This has been explained earlier in this book but I thought I would refresh your memory here.

What Is Binary?
Binary Notation, or base-two as it’s sometimes called, is a numerical system where the digits of a binary number can only have one of two values, ‘0’ or ‘1’. Similar to the Decimal system (which is sometimes called base-ten) each position of a binary digit represents another quantity.

Let me explain this concept a little more clearly, here is an example of a decimal number:

542

In this example, the ‘2’ digit is in the position associated with the quantity one, the ‘4’ digit is in the position associated with the quantity ten and the ‘5’ digit is in the position associated with the quantity hundred. Each associated quantity is ten times the quantity to its right. To find out what number this represents you simply multiply the value of each digit by the quantity associated with that digit’s position and then add those results together i.e. (‘5’ x hundred) + (‘4’ x ten) + (‘2’ x one) = ‘542’ (five hundred and forty two).

This is also how binary (base-two) numbers work when dealing with integers. The position of each digit in a binary number is also associated with a quantity, except that the quantity associated with each position is twice that of the position to it’s right, this is base-two after all. While that might sound like a mouthful, its surprisingly easy to understand using a diagram. Look at Fig.44.

<<Fig 44>>

To extract the value represented by this binary number, we follow the same procedure as in decimal (base-ten). We multiply the value of each digit by the quantity associated with its position then add the results. For example, the value represented by ‘01001101’ as shown in Fig.44 is ‘77’. Since binary notation only uses the digits 0 and 1, this ‘multiply-and-add’ process demonstrated earlier with base-ten numbers, reduces to just addition of the quantities associated with the positions occupied by a binary value of ‘1’. So, if you look at Fig.44 and add up the quantities of where a binary value of ‘1’ appears, you get: ‘64 + 8 + 4 + 1 = 77’.

You can probably see now from Fig.44 that only a finite amount of numbers can be represented in binary using only this number of bits. This is why certain types have certain limits, they simply run out of bits to use. Bigger types work in exactly the same way, they just have more bits to calculate.

Signed And Unsigned Integers
Earlier on in Fig.2, you can see many of PureBasic’s integer types range from negative to positive numbers. These are known as Signed number types, because their values can potentially contain a negative sign. Unsigned types, on the other hand, refer to integer types which have a numerical limit that ranges from zero to a larger positive number. The PureBasic Character type is an example of an unsigned integer type and which is also shown in Fig.2. Because there is only a finite number of bits allocated by these data types, there are two methods needed to interpret these binary numbers depending on wether they should be read as signed or unsigned.

<<Fig 45>>

If you take a look at Fig.45 every integer data type has two ways of being read. The Byte for example, can be both signed and unsigned, and both flavors can contain a value taken from a range of two hundred and fifty six (256) possible numbers, including zero...yes, zero is a number too!

Reading Unsigned Integers Using Binary
An unsigned number is easy to represent in binary as we have seen from Fig.44. You just keep turning the bits to 1 and add together the associated values where a ‘1’ appears. For example, the maximum value of an unsigned Byte expressed using binary is ‘11111111’ (‘255’) where all the bits are set to ‘1’. Nice and simple.

Reading Signed Integers Using Binary
A signed integer follows slightly different rules to express using binary. PureBasic uses a system called Two’s Complement to express signed integers. In two's complement form, the left most bit of a signed binary number (sometimes called the most significant bit) indicates if the actual sign (-) is present in the integer. If the left most bit is ‘0’ the integer being expressed by the bits is a positive integer and can be read by using the unsigned binary method explained earlier. If the left most bit is ‘1’ the integer being expressed is negative and must be read using two's complement form, as explained below.

Because the left most sign bit is reserved to indicate wether a sign is present or not you are only left with the remainder of bits to express the rest of the integer. Let’s take a Byte as an example again, if we left the sign bit as ‘0’ to express a positive number that only leaves us with seven remaining bits to make a number out of, so we’ll turn all these to ‘1’, like this: ‘01111111’. This is now expressing the maximum positive integer that a signed Byte can hold, which in this case is ‘127’.

If we want to express a negative integer using binary we have to do it in a slightly different manner. Let’s first look at the unsigned binary representation of the number ‘9’, which is ‘00001001’. The left most bit is zero so we know for definite this is a positive integer. To convert this to two’s complement form and express it as a negative integer, we first need to invert the bits and then we add one (‘1’) to the inverted binary number. So the number ‘-9’ looks like this: ‘11110111’. When I talk about inverting the bits, what I mean is that if a bit is ‘0’ then change it to ‘1’, and if a bit is ‘1’ then change it to ‘0’ and do this for all bits contained in the type. As you can see the left most bit is now ‘1’ indicating this binary number represents a negative (signed) integer. Inverting the bits and adding ‘1’ to a positive integer is the two’s complement method of expressing that integer’s negative form.

To convert this negative integer back to its positive form, you follow exactly the same procedure. After inverting ‘-9’ (‘11110111’) the binary number now looks like this: ‘00001000’, we then add one (‘1’) to this number and it becomes: ‘00001001’, which gives us a positive ‘9’ when read using the normal unsigned binary method. Fig.46 shows a signed Byte visually holding the value of ‘-9’.

<<Fig 46>>

Even though I’ve used the Byte type in these last few sections to describe how to read binary, these methods are universal for any numerical integer type no matter what its size. In all integer types the associated quantities of each bit position grows by a power of ‘2’ as you move to the left within the binary number. In signed binary numbers, the left most bit is always the sign bit.

Floating Point Numbers And Binary
A floating point number is a number which contains a decimal point and which can be either negative or positive. Numbers like these are stored in a way that makes the point ‘float’ around the number, so that it is possible to store very large or very small numbers. Using a storage method like this makes it possible to have a huge range of numbers that can be stored but at the cost of numeric accuracy. Even though floating point numbers are extremely versatile, you have to account for the fact that some precision may be lost if you are storing a lot of decimal places.

PureBasic currently supports two data types to handle floating point numbers, these are the normal Float type and the Double type. The difference between these two types is the amount of bits they use to store the floating point number. A Float uses 32 bits (4 Bytes) and a Double uses 64 bits (8 Bytes), so obviously Doubles are a lot more accurate for holding large numbers. So why not use Doubles all the time, instead of Floats? Well, speed for one. Floats can be a lot faster at reading from memory especially when using large Float arrays. This is because of the fact that you are only retrieving half the number of Bytes from memory than you would be with Doubles. Usually programs such as games tend to use Floats while programs that need more accuracy tend to use Doubles. 

Storing Floating Point Numbers Using Binary
Because of the special nature of floating point numbers, which need to store a decimal point along with a large number to the right, left or both sides of that point, a different method of storing numbers in binary is used. This method is quite complicated and is described in the ‘IEEE 754’ standard for binary encoding of floating point numbers. I’ll see if I can describe it as simply as possible.

First, all floating point numbers are stored in three binary parts. These parts are the Sign, the Exponent and the Significand. These three parts all fall inside the bit limit as defined by using either a Float or a Double. See Fig.47.

<<Fig 47>>

Here, you can see how the type is divided internally to support each of the three sections. Now all we need to understand is how a floating point number is encoded to fit into these sections. The sign bit is probably the easiest of the sections to explain. If the number to be encoded is positive then the sign bit will be ‘0’ and if the number is negative the sign bit will be ‘1’. Let’s start with an example number and I’ll demonstrate how it is encoded into a 32 bit Float. Let’s take the number: ‘10.625’.

Step One, Encode The Number To Binary
To encode this number to fit within the binary sections of a Float we have to follow several steps. The first, is we have to convert both sides of the decimal point into binary, like this:

‘10.625’ = ‘1010.101’

This might look a little odd because you will probably not have seen a decimal point (or radix point as it’s more accurately called here) within a binary number. This is only to visualize the number at this stage so don’t be alarmed. Encoding a number into binary like this is a little different from what was explained before, because you are dealing with a whole number on one side of the radix point and a fraction on the other side. The whole number part is the easy one to encode because it follows standard unsigned binary encoding as explained in Fig.44, i.e. decimal ‘10’ = binary ‘1010’. The fractional part on the other hand uses a similar method but in the binary representation of a fraction the associated quantities are fractions themselves instead of whole numbers. Also, for these binary numbers, we don’t pad them with unnecessary zeros.

In standard unsigned binary, associated quantities start at ‘1’ and increase by a factor of ‘2’ the further left you go along the binary number, while in fractional binary the associated quantities start at ‘0.5’ and decrease by a factor of ‘2’ the more right you go along the binary number. Take a look at Fig.48.

<<Fig 48>>

Here, you can see the associated quantities of the fractional binary number starting at ‘0.5’ and decreasing by a factor of ‘2’ in each place moving to the right, so they are calculated as, ‘0.5’, ‘0.25’, ‘0.125’, etc. The more places you go to the right the more precision a fractional number can contain. Because our number has a fractional part of ‘.625’ it is easily represented by ‘0.5’ + ‘0.125’ so that’s where the binary ‘1’s appear.

Knowing how a fractional number is represented in binary does not necessarily help you to encode it though, especially when dealing with huge decimal fractions. Luckily though there is an easy way to encode these numbers using the ‘doubling’ trick.

First, we take our starting fraction ‘.625’ and double it and see if it is above or equal to ‘1.0’. If it is then we mark down a binary ‘1’. We then take the fractional part of the last sum and double and test it again. If at any stage the doubling does not produce a number which is equal to or above ‘1.0’ then we mark down a binary ‘0’. Here’s how this works in practice:

.625 * 2 = 1.25 - This is above or equal to ‘1.0’ so we mark a binary ‘1’.
.25 * 2 = 0.5 - This is not above or equal to ‘1.0’ so we mark a binary ‘0’.
.5 * 2 = 1.0 - This is above or equal to ‘1.0’ so we mark a binary ‘1’.

When no more fractional parts are available to test or you have run out of bits to fill you stop calculating. If you now look at the resulting binary digits from these calculations reading from top to bottom you can see it’s ‘101’, exactly as expected for ‘.625’.

Now we know how to encode a fractional decimal number into binary, I can continue to explain how these numbers are encoded in 32 bit Floats. So, step one was first to encode our number into a binary form, like this:

‘10.625’ = ‘1010.101’

Step Two, Move The Radix Point And Calculate The Exponent
In this step we need to move the radix point, as this will not be encoded in the final binary number. Because the radix point defines where the decimal point is in the decimal version of this number we do actually need to remember where it was, so we can put it back to its original position when it’s decoded. To do this we shift the radix point along the binary number until there only remains a ‘1’ to it’s left. Any extra zeros on the left can be ignored but their positions must be counted if the radix point moves past them. Look at this example:

‘1010.101’ (original)
‘1.010101’ (Radix point moved 3 places to the left)

When moving the radix point we need to note of how many places we move it. Here, I’ve moved it ‘3’ places to the left to leave a leading ‘1’ to the left of it, so the number of places the radix point has moved will be a positive number. If the original binary number was something like ‘0.0001101’ then I would have to move the radix point to the right to leave a single leading ‘1’ to the left of it (disregarding the zeros) which would give me a negative radix point movement value of ‘-4’. (I’ll explain about this ‘1’ always being to the left in a minute).

The number of places you need to move the radix point to leave only a leading ‘1’ to its left, is noted as the Exponent. This exponent is then added to a preset number (depending on what size of floating point type you are using), to make sure it is encoded as an unsigned number. For example, when using a 32 bit Float the number you have to add ‘127’ this is called the Exponent Bias.

In our original example, we moved the radix point ‘3’ places to the left (which is a positive 3), so we add ‘127’ to ‘3’ and get ‘130’. This number is then encoded to binary using the standard unsigned method as described in Fig.44, which would be ‘10000010’. This is then saved in the exponent section within the 32 bit Float as shown in Fig.47. Because we save the number of places the radix point has moved, this means that the bit count of the exponent section actually imposes a limit on how far we can record the radix point moving. This limit is ‘127’ places to the left and ‘(-)126’ places to the right. Anything above ‘127’ and the number is considered to be ‘infinite’ and anything below ‘-126’ the number is considered to be a denormalized number of which is a special case where the exponent is kept at ‘-126’ and the leading ‘1.’ is changed to a leading ‘0.’.

Step Three, Calculate The Significand
The significand is the part of the floating point number which contains the significant part of the number. In fact this is where the actual number is stored, the exponent merely tells you where the radix point should sit relative to the significand. After moving the radix point in step two, our binary number should now look like this: ‘1.010101’

To calculate the significand from this, we first completely disregard the ‘1’ at the beginning of this binary number. This ‘1’ never has to be encoded because it is always there, any number we want to encode using a floating point type will always have a ‘1’ there, so it’s completely safe to disregard as long as we remember to put it back when we decode this binary number. Disregarding this number allows us to gain one more bit within the significand to help us represent the original decimal number. Remember the more bits we have, the more precisely we can be to represent the original.

After disregarding the ‘1’ in front of the binary number the radix point is then meaningless too, so we can get rid of that as well. So now the binary number looks like this: ‘010101’. This is our significand. If the significant is smaller than 23 bits as in this example we need to pad this number with zeros to make it up to the 23 bit length it should be. These zeros must be on the right hand side, like this: ‘01010100000000000000000’. This is now the full significand which is saved in the significand section within the 32 bit Float as shown in Fig.47.

So in total the binary representation of the number ‘10.625’ would be:
‘0 10000010 01010100000000000000000’

Limitations Of Floating Point Numbers
Even though floating point numbers are very versatile, they are also inherently inaccurate because of the way the number is stored using binary. Do not be shocked to see a number being read from a Float that was different to what was originally assigned to it. Only about 7 decimal digits are represented correctly in single precision Floats, and about 16 in Doubles. Precision of decimal numbers can also be lost when performing arithmetic with floating point numbers too, chipping away at the overall precision again. This is always something to keep in mind when using Floats and Doubles.

Using Binary Numbers Directly In PureBasic
Binary numbers can be assigned to variables directly by using the ‘%’ prefix. Using the percent sign like this should not be confused with the modulo operator from Chapter 3 (An Introduction To Operators) even though they use the same symbol. PureBasic recognizes this as a binary assignment because there isn’t an expression to the left of it and there is no space to the right of it. Here’s an example:

BinaryVariable.b = %01101101
Debug BinaryVariable

All PureBasic’s numerical types can be assigned using binary like this.

Pointers

I think its fair to say that pointers in computer programming scare a lot of people. I have no idea why, because pointers can give you immense power when dealing with certain programming problems. Maybe it’s the fear of the unknown that makes people avoid them? I don’t know, but what I do know is that, when pointers are explained to people properly, they always wonder why they avoided them for so long. This next section is about pointers and how PureBasic creates and uses them and what advantages they give you as a programmer.

So what is a pointer? Well, put simply, a pointer in PureBasic is a variable that holds a numeric address of a location in memory. It’s that simple! So what are memory addresses? Well, just think of all the Bytes in memory each being associated with a unique number, as if they are all inside a huge array. Every Byte in memory can be looked up via it’s number (address). Because there are thousands of Bytes present in modern computer systems these numbered addresses are usually quite large numbers.

Getting A Memory Address
Now we know that a pointer is just a variable that holds a memory address, we now need to know how to get the memory address of something useful. For this we use special one character functions that return the memory address of the data objects they prefix.

<<Fig 49>>

In Fig.49 you can see the two special memory address functions and which data objects they work with. The ‘@’ function is the most versatile as it works with variables, arrays and procedures. The ‘?’ function is reserved for labels. Here’s a simple example showing how to retrieve the memory address of a Byte variable:

MyByteVar.b = 100
Debug MyByteVar
Debug @MyByteVar

In this example, I’ve defined a Byte variable called ‘MyByteVar’ which is given the value of ‘100’, which is all pretty straightforward. In the last line of code, I retrieve that variable’s memory address by using ‘@’ in front of its name. Using ‘@’ like this will return the memory address of ‘MyByteVar’ which I’ve then echoed to the Debug Output window. If you run the above example and look in the Debug Output window you will see that the original value of ‘100’ is displayed along with the address of the Byte variable beneath it. The address is typically a huge number, usually about seven or eight digits long and this address may change depending on what computer you run it on. This is because some machines may allocate memory for the storage of that Byte in slightly different ways.

When I run the this example on my PC, I get this displayed in the Debug Output window:

100
4298004

This tells me that the Byte variable which is used to store the value of ‘100’ is located at memory address ‘4298004’.

Using these special memory address functions, it’s possible to get the memory address of all variable types, arrays, procedures and labels, which can be very useful. Here is an example which would be pretty useless in the real world, but demonstrates getting the addresses of all these different data objects and echoing these memory addresses to the Debug Output window:

MyByteVar.b = 1
MyWordVar.w = 2
MyLongVar.l = 3
MyQuadVar.q = 4
MyFloatVar.f = 5
MyDoubleVar.d = 6
MyStringVar.s = "Seven"
Dim MyLongArray.l(8)

Procedure MyProcedure(Test.l)
	Debug "Testing my procedure."
EndProcedure

Debug "Byte variable address: " + Str(@MyByteVar)
Debug "Word variable address: " + Str(@MyWordVar)
Debug "Long variable address: " + Str(@MyLongVar)
Debug "Quad variable address: " + Str(@MyQuadVar)
Debug "Float variable address: " + Str(@MyFloatVar)
Debug "Double variable address: " + Str(@MyDoubleVar)
Debug "String variable address: " + Str(@MyStringVar)
Debug "Array address: " + Str(@MyLongArray())
Debug "Procedure address: " + Str(@MyProcedure())
Debug "Label address: " + Str(?Label)

DataSection
	Label:
		Data.s "Testing"
EndDataSection

Notice when getting the address of arrays, procedures or labels you do not need to specify any decoration such as type identifiers, array dimensions, or parameters, etc. And even though the array in the above example was defined like this:

...
Dim MyLongArray.l(8)
...
To get its memory address you just need to use its name with brackets on the end, like this:

@MyLongArray()

Similarly, when getting the address of a procedure, you only need its name with brackets:

@MyProcedure()

No types or parameters are needed. The same is also true for labels. Even though they are defined using a colon on the end of their name, the colon is completely omitted when using them with a memory address function, like this:

?Label

Getting the memory address of all these different data objects is easy because of the simple way that the memory address functions work. To begin with, and for clarity’s sake, I would recommend that all retrieved memory addresses are kept within variables, to keep code neat and readable, always remembering to give them good meaningful names.

Creating And Naming Pointers
As I said in the beginning, a pointer is a variable that holds a numeric address of a memory location, but what I didn’t say is that a pointer is a special kind of variable that follows a few rules. For a start, pointers in PureBasic are created by using an asterisk ‘*’ as the first character in its name. Like this:

*Pointer

Secondly, pointers are a numeric type that can change size depending on what computer architecture is compiling the program. For example, on a 32 bit system, a pointer will use 4 Bytes of memory to store a number, while on a 64 bit system, a pointer will use 8 Bytes to store a number.

Also a pointer in PureBasic is not associated with any particular type. Meaning that if you define a pointer using an asterisk along with any of the built-in numeric types, the built-in type is discarded to make sure the pointer is the correct size for your particular computer architecture. So if you defined a pointer like this, using a Byte type:

*Pointer.b = @Variable

The Byte type is discarded and the pointer will still use 4 Bytes on a 32 bit system and 8 Bytes on a 64 bit system.

This asterisk used as part of the pointer name, is also a permanent character, meaning that once you have defined your pointer then you have to keep it as part of its name when using it. For example, these two are completely different and have no relationship towards each other:

MyVariable.l
*MyVariable.l

Even though the only difference between these variables is the asterisk, the first variable is a Long type variable, while the second one is a pointer (defined by the asterisk). In other languages, an asterisk prefixes variables to return its value or memory address interchangeably, so it’s important to understand that PureBasic doesn’t have this extended functionality. They are treated as two entirely different variables.

Using asterisks to create pointer variables is an effective way to differentiate them from other types in PureBasic, and giving you a good visual indication of what data they may hold. In the helpfile, all the syntax examples that deal with memory also use this convention to help programmers know where pointers are needed. Just take a look at some of the syntax examples of the memory commands (Helpfile:Reference Manual->General Libraries->Memory), there are asterisks everywhere.

Using this convention, the first example can be re-coded like this:

MyByteVar.b = 100
*MemoryAddress = @MyByteVar
Debug MyByteVar
Debug *MemoryAddress

Notice the asterisk prefixing the pointer name? Using this method it’s easy to spot which variables are pointers and which are not.

Accessing Memory In A Structured Way, Via A Pointer
In this next example I’ll show you how you can use a pointer to act as a structured variable. This pointer is the same size as any other but we can access the memory that it points to in a more structured way.

Structure DETAILS
	Age.l
	Height.l
EndStructure

My.DETAILS
My\Age = 32
My\Height = 168

*Pointer.DETAILS = @My

Debug *Pointer\Age
Debug *Pointer\Height

Here, you can see I’ve defined a structure called ‘DETAILS’ which contains two Long fields. Immediately after that, I define a variable called ‘My’ using this structure and assign some data to the String fields within it. Now this is where the special function of the asterisk can be helpful when creating a pointer. If we create a structured variable pointer using an asterisk, we are able to set its value by assigning to it a memory address, like this:

*Pointer.DETAILS = @My
This creates a pointer called ‘*Pointer’ and sets its value to be the memory address of the ‘My’ structured variable. Because we used a structure as a type when defining this ‘*Pointer’ variable, we can access the memory it points to in a structured way.

So these two lines that are echoing data to the Debug Output window:

Debug *Pointer\Age
Debug *Pointer\Height

are actually echoing the data contained within the ‘My’ structured variable, we are just retrieving this data using our newly created pointer. Again, the pointer created here is just a variable which contains a numeric memory address, it’s not making a duplicate of any data. Fig.50 shows visually how this works in memory.

<<Fig 50>>

So what is this useful for? Well, it could be used to return more than one value from a procedure. For example, you could create a ‘Static’ structured variable within a procedure and assign it values. Then return it’s memory address from the procedure. This memory address can then be used to create a structured variable pointer giving you access to that data which was assigned in the procedure. Kind of like this:

Structure MEALS
	Breakfast.s
	Dinner.s
	Tea.s
EndStructure

Procedure.l GetMeals()
	Static Gary.MEALS
	Gary\Breakfast = "Cornflakes"
	Gary\Dinner = "Cheese sandwiches"
	Gary\Tea = "Spaghetti bolognese"
	ProcedureReturn @Gary
EndProcedure

*Gary.MEALS = GetMeals()

Debug *Gary\Breakfast
Debug *Gary\Dinner
Debug *Gary\Tea

We use the ‘Static’ keyword here to preserve the data in the ‘Gary’ structured variable when the procedure returns, otherwise it will be destroyed. The memory address returned by this procedure is then assigned to the structured variable pointer called ‘*Gary’ (notice the asterisk). We can then access that memory using the ‘MEALS’ structure. As you can see, very handy indeed.

For added flexibility memory addresses from any variable type can be assigned to a newly created structured variable pointer, even PureBasic’s built-in types can be used. Here’s a demonstration:

Structure SCREENCOORDS
	x.w
	y.w
EndStructure

Coordinates.l = %00000011000000000000010000000000
*Screen.SCREENCOORDS = @Coordinates

Debug *Screen\x
Debug *Screen\y

Here, I define a Long type 32 bit variable using binary and call it ‘Coordinates’. Then I assign its memory address to a newly created structured variable pointer called ‘*Screen’. Because the structure I used for the pointer contains two 16 bit Words, the 32 bit value pointed to won’t fit into just one of the fields but will overlap across both of them, split in the middle. This allows me to return two values from this one variable, giving you the two ‘x’ and ‘y’ values.

Passing A Structured Variable Into A Procedure Via A Pointer
Any structured variable can be passed into a procedure as a pointer to allow that procedure to manipulate it. This is the only way in PureBasic that you can actually pass a structured variable into a procedure. When passing structured variables like this, you are actually passing them ‘By Reference’, very similar to arrays and linked lists. What this means is that values aren’t actually ‘copied’ into any parameters. Instead a pointer is passed to the procedure and this is used to manipulate the original structured variable. One of the main things you need to consider when using this method, is that when you pass a structured variable into a procedure, the parameter name of that procedure might not have the same name as the structured variable you are passing, but whatever name you give to the parameter, you are still manipulating the original passed structured variable. Here’s an example:

Structure COORDINATES
	x.l
	y.l
EndStructure
Point.COORDINATES

Procedure IncreaseValues(*Var.COORDINATES)
	*Var\x + 10
	*Var\y + 10
EndProcedure

Point\x = 100
Point\y = 100

IncreaseValues(@Point)
Debug Point\x
Debug Point\y

Here, I’ve defined a structure called ‘COORDINATES’ and created a structured variable from it called ‘Point’. When all field values have been assigned to this variable, I then pass its memory address to the ‘IncreaseValues()’ procedure.

In the definition of the ‘IncreaseValues()’ procedure, I’ve defined one parameter in the form of ‘*Var.COORDINATES’. A parameter defined like this tells the procedure to expect a pointer from a structured variable which has been created from the ‘COORDINATES’ structure. The name ‘*Var’ can be anything you like (as long as it’s prefixed by an asterisk), it’s merely used as a friendly way to manipulate the passed pointer. So, when I do this in the above procedure:

...	
*Var\x + 10
*Var\y + 10
...

What I am really doing is this:

Point\x + 10
Point\y + 10

because the procedure is manipulating the data stored at the passed memory address.

Using this method of passing structured variables to procedures can be very handy for situations where you want to pass lots of information nicely grouped together. For example, Address details, configuration details or any specifically grouped settings or values. Also using this method you can have less parameters being passed to procedures, as you can pass them all in one structured variable. As an example of real world use, I wrote an email procedure a few years ago, to which I could pass a structured variable containing the mail account details along with the recipient, subject and message, etc... It just makes things a little more readable and manageable.

Reading And Writing Values Using Pointers
When you retrieve a memory address, you are able to use it in a variety of different ways. Arguably the most common way is reading values from that memory location or storing new data there. This is called peeking and poking. You use a ‘Peek’ command to retrieve data from a memory location and use a ‘Poke’ command to store new data there.

In PureBasic there are eight ‘Peek’ commands and eight ‘Poke’ commands to accommodate fully all of the built-in data types. Each one of these commands are named in pretty much the same way, except the last letter of the command name is the same as the type it works with. For example, if you want to peek a Byte from a particular memory address, you would use the command called ‘PeekB()’ which (as the ‘B’ in its name suggests) would return a Byte from that location in memory. Similarly, if you wanted to poke a String into a particular memory address, then you would use ‘PokeS()’. All these sixteen commands can be read about in more detail in the ‘Memory’ section within the PureBasic helpfile (Helpfile:Reference Manual->General Libraries->Memory).

Peeking Values Held In Memory Locations
Using a peek command is quite straightforward, you pass it a memory location (maybe being held inside a pointer) and the peek command will return the data that resides there. To return a particular data type you have to use the associated peek command. Here is an example of peeking a Byte from a memory location using the ‘PeekB()’ command:

Weight.b = 30
*Weight = @Weight
ReadValue.b = PeekB(*Weight)
Debug ReadValue

Here, I assign the value ‘30’ to a Byte variable named ‘Weight’. In the next line I assign its memory address to a pointer called ‘*Weight’ (Notice the asterisk). The next line contains the ‘PeekB()’ command which actually reads a Byte value from the passed pointer and returns it. You are not forced to use pointers for the address parameter (although it is advisable for the sake of clarity), we could of written this example like this:

Weight.b = 30
ReadValue.b = PeekB(@Weight)
Debug ReadValue

Here, I use the Byte variable with the memory address function directly, completely doing away with the pointer altogether. I guess it depends what you are most comfortable with. At the end of the day, all the ‘Peek’ commands need a memory location as a parameter, which ultimately can be supplied by a defined pointer or (more directly) by the return value of a memory address function.

Poking Values Into Memory Locations
Poking values into memory locations is just as easy as using a ‘Peek’ command. For poking however, you need to supply a new value along with the memory address of where to put it. Here’s an example of poking a new Long value into an existing Long variable’s memory location:

Weight.l = 1024
*Weight = @Weight
PokeL(*Weight, 333)
Debug Weight

Here we start with the original value of ‘1024’ being assigned to the ‘Weight’ variable. Then I’ve created a pointer called ‘*Weight’ which contains the memory address of ‘Weight’. The ‘PokeL()’ command is then used to poke the value of ‘333’ into the memory location specified in the first parameter. The new value of ‘Weight’ is then echoed to the Debug Output window.

A Word Of Warning When Poking New Values
Be very careful about where you are poking new values. Using PureBasic’s memory commands can be quite dangerous of you don’t know what you are doing. For example, the ‘Poke’ commands have no internal checking to tell you wether or not you can safely poke a value into a particular memory address. You could pass a random number to any ‘Poke’ command as a memory address and it will quite happily poke a value into it. This is a double edged sword, because you sometimes need this power to re-arrange values in memory but it can lead to problems. If you get it wrong, you could mess up a memory location that some essential program might need to read. Leading to a program crash or something more damaging, like an operating system crash.

To safely poke values into memory you should poke into an existing variable or array’s memory location or poke into memory allocated using the ‘AllocateMemory()’ command (Helpfile:Reference Manual->General Libraries->Memory->AllocateMemory). Ensuring that any values poked into these memory areas do not exceed the allocated space. For example, it would be bad practice to poke a Long value into a Byte variable’s memory location, because you are poking 3 more Bytes of data than you should be. This would actually work though, because there is no error checking, but you would overwrite 3 Bytes of potentially essential data, corrupting whatever was there.

Using A Memory Address As A Start Index
When using contiguous blocks of memory to peek values from or to poke values into, it’s possible to use the starting Byte’s memory address as a starting index for the rest of the block. This is especially useful when using pointers to arrays. Take a look at this example:

Dim Numbers.l(2)

Numbers(0) = 100
Numbers(1) = 200
Numbers(2) = 300

*ArrayPointer = @Numbers()

Debug PeekL(*ArrayPointer)
Debug PeekL(*ArrayPointer + 4)
Debug PeekL(*ArrayPointer + 8)

After creating an array of Long type variables called ‘Numbers’ I assign each of it’s indices a numerical value, ranging from ‘100’ to ‘300’. Once this is done I create a pointer called ‘*ArrayPointer’ which holds the array’s memory address.

When you create any array like this, all its indices are created in a continuous block of memory, so all data that the array holds is stored next to one another. The memory address returned by a memory address function prefixing an array, is the address of the first index. In effect, the pointer called ‘*ArrayPointer’ holds the memory address of the array index ‘Numbers(0)’.

When we use a line of code like this:

...
Debug PeekL(*ArrayPointer)
...

We are peeking the value from the first index’s memory location. You can see this is true by the first value echoed to the Debug Output window. To peek other values from the array, we must use this pointer as a starting location and add to it the number of Bytes we wish to move through memory by. We know that Long types use four Bytes so we can increase the pointer by ‘4’ to retrieve the next Long value held inside the memory that’s allocated to this array. The following lines of code, from the above example does just that, they peek values from further into the array’s memory by using the array’s pointer as a starting location.

...
Debug PeekL(*ArrayPointer + 4) ;This echoes the second Long value: ‘200’
Debug PeekL(*ArrayPointer + 8) ;This echoes the third Long value: ‘300’

I’ve shown this visually in Fig.51. If I was using an array of Bytes then of course I would have to increase the array’s pointer by ‘1’ to peek the second Byte and by ‘2’ to peek the third, etc.. Similarly, if I was using Word types, then the pointer would have to be increased by ‘2’ Bytes each time.

<<Fig 51>>

Threads

A thread is a single sequence of instructions executed as a separate task but still remaining part of the originating program. Any program can have several threads running concurrently, each performing a different task, such as waiting for events or performing a time-consuming job. Threads are an offshoot of the main program, that can execute instructions independently of it. If the originating program is closed, then the thread will automatically be stopped and destroyed too. So, what kind of programs would use threads? Well, any program can potentially use them, but mainly they are coded into programs that need to do more than one thing at once. For example, if you wrote a search tool to search for files on your hard drive, you would probably write the search code to be executed from within a thread. This would then not interfere with the redrawing of the GUI or the event handling in the main loop. The searching could be done independently, without impairing the responsiveness of the main interface. For another example, you may have a program that manipulates large files. Because these files take quite a while to manipulate in whatever way, you may want to deal with them in a thread, so that the main program can be doing other things. These are just two of the many ways threads could defeat a particular programming problem.

Using Threads
Before I continue showing you how to use threads, let me show you a simple program that isn’t threaded to base a comparison upon. This example calls a procedure twice, each time to insert values into two different list view gadgets. Notice that when you press the ‘Start Test’ button, you can’t move the window or see any text actually being entered into the gadgets until both procedure calls have finished.

Enumeration
	#WINDOW_ROOT
	#LIST_ONE
	#LIST_TWO
	#BUTTON_TEST
EndEnumeration

Procedure InsertText(Gadget.l)
	For x.l = 1 To 25
		AddGadgetItem(Gadget, -1, Str(x))
		Delay(100)
	Next x
EndProcedure

#FLAGS = #PB_Window_SystemMenu | #PB_Window_ScreenCentered
If OpenWindow(#WINDOW_ROOT, 0, 0, 290, 200, "Thread Test", #FLAGS)
	If CreateGadgetList(WindowID(#WINDOW_ROOT))
		ListViewGadget(#LIST_ONE, 10, 10, 130, 150)
		ListViewGadget(#LIST_TWO, 150, 10, 130, 150)
		ButtonGadget(#BUTTON_TEST, 95, 170, 100, 20, "Start Test")
		Repeat
			EventID.l = WaitWindowEvent()
			Select EventID
				Case #PB_Event_Gadget
					Select EventGadget()
						Case #BUTTON_TEST
							InsertText(#LIST_ONE)
							InsertText(#LIST_TWO)
					EndSelect
			EndSelect
		Until EventID = #PB_Event_CloseWindow
	EndIf
EndIf
End

You will also notice that when you run this example, the two procedure calls to ‘InsertText()’ in the main loop are run one after another. Meaning, the first procedure will have to finish before the second one can begin, this is after all, how procedural programs work. In this case, that doesn’t really matter to us, because we can’t see any updates happening in the list view gadgets because of the ‘Delay()’ command used in the ‘InsertText()’ procedure.

<<Box 27>>

This delay is even delaying the program from processing internal messages to re-draw the user interface or handle the movement of the window within the operating system. We just click the button and have to wait for the procedures to finish before we can interact with the program again. Now imagine if this was an image processing program, and these two procedures take thirty minutes to finish whatever they do. That’s a lot of time to wait until you can move that program’s window or see any update in the user interface. We wouldn’t even be able to draw a progress bar!

If we want both of these procedure calls to run at the same time and be completely independent of the main user interface, we could create two threads to run at the same time as the main program. This is how you could do it:

Enumeration
	#WINDOW_ROOT
	#LIST_ONE
	#LIST_TWO
	#BUTTON_TEST
EndEnumeration

;Insert text into the specified list gadget
Procedure InsertText(Gadget.l)
	For x.l = 1 To 25
		AddGadgetItem(Gadget, -1, Str(x))
		Delay(100)
	Next x
EndProcedure

#FLAGS = #PB_Window_SystemMenu | #PB_Window_ScreenCentered
If OpenWindow(#WINDOW_ROOT, 0, 0, 290, 200, "Thread Test", #FLAGS)
	If CreateGadgetList(WindowID(#WINDOW_ROOT))
		ListViewGadget(#LIST_ONE, 10, 10, 130, 150)
		ListViewGadget(#LIST_TWO, 150, 10, 130, 150)
		ButtonGadget(#BUTTON_TEST, 95, 170, 100, 20, "Start Test")
		Repeat
			EventID.l = WaitWindowEvent()
			Select EventID
				Case #PB_Event_Gadget
					Select EventGadget()
						Case #BUTTON_TEST
							Thread1.l = CreateThread(@InsertText(), #LIST_ONE)
							Thread2.l = CreateThread(@InsertText(), #LIST_TWO)
					EndSelect
			EndSelect
		Until EventID = #PB_Event_CloseWindow
	EndIf
EndIf
End

If you look closely, the only difference between these two examples is how the procedures have been called. Every newly created thread in PureBasic starts life as a standard procedure, defined as usual in the source code and always defined with one parameter. To create a thread from it, you use the ‘CreateThread()’ command (Helpfile:Reference Manual->General Libraries->Thread->CreateThread) which itself takes two parameters. The first is the memory address of the procedure you want to launch as a thread. The second is a mandatory parameter which can be of any type. You always have to pass this parameter to the procedure even if you use it or not, here I’ve used it to specify which gadget to insert the text to.

When creating a thread like this, if the ‘CreateThread()’ command returns a value that is greater than zero the thread has been successfully created and has been immediately launched. Also, this value (if successful) is a Long type thread identifier that can be used with other commands from the ‘Thread’ library (Helpfile:Reference Manual->General Libraries->Thread).

So let’s recap on what rules we must follow to create a thread from a procedure.

1). The thread procedure must have one, and only one parameter.
2). No value can be returned by the thread procedure. If it does return a value, it will be lost.

When this threaded example is run, you will see values being inserted to both of the list view gadgets in realtime. While these value are being inserted, you can also move the program’s window around the screen and you will notice that it is now being redrawn and updated as normal. The two newly created threads have become independent parts of the same program, which run at the same time as it. If the main program should close at any time, these two threads will be terminated and closed too.

If you notice any garbled text being inserted into any of the gadgets, you must ensure that the ‘Create Threadsafe Executable’ compiler option is enabled, as described in the ‘Compiling Thread Safe Programs’ box.

Waiting For Threads To Finish
Using threads can be a bit tricky sometimes, and can sometimes introduce new problems while solving others. If you use threads in your main program, they are always at the mercy of that program’s life span. Meaning, that when the main program finishes or is closed by a user, the associated threads are terminated too.

In PureBasic you can get around this problem by using the ‘WaitThread()’ command (Helpfile:Reference Manual->General Libraries->Thread->WaitThread). This command will make sure a thread has completed its task before continuing with the main program. Here’s an example:

Procedure DrawNumbers(Unused.l)
	For x.l = 1 To 20
		PrintN(Str(x))
		Delay(75)
	Next x
EndProcedure

If OpenConsole()
	ThreadID.l = CreateThread(@DrawNumbers(), 0)
	WaitThread(ThreadID)
	Print("Press Return to quit") : Input()
	CloseConsole()
EndIf
End

After the thread creation line you can see I’ve used the ‘WaitThread()’ command. This takes one parameter which is a thread identifier of a previously created thread. This command will halt normal program execution until the thread specified in the thread identifier has finished running, or in other words, until the procedure used to create the thread has completed its task. The ‘WaitThread()’ command can take an optional second parameter if needed, which specifies a time-out value in milliseconds. Once this time-out value has elapsed, the program execution is resumed regardless of the specified thread’s state. I’ve not used this optional second parameter in my example because I want to make sure the threaded procedure has finished before you are able to ‘End’ the program. If you comment out the ‘WaitThread’ line of code, you will notice that you can press the Return key at any time while the program is running and close it, effectively cutting short the thread’s task. With the ‘WaitThread()’ command in place however, you have to wait for the thread to finish before the keypress is acted on.

Using Shared Resources Safely
When using many threads in the same program, you have to code their actions very carefully, especially if your allowing these threads to use shared resources. Having many threads attempting to read and write to the same file or memory location at exactly the same time is always going to end in corrupted files and a lot of tears. To avoid this, PureBasic provides a simple mechanism for only allowing one thread at a time to gain access to any shared resource. This mechanism is in the form of a Mutex.

A Mutex is a data object that can be used as a lock to stop threads using a resource if it’s being used by another thread. Once used in your code to protect a shared resource, a mutex will prevent threads from proceeding unless they have locked it. Once a thread has locked the mutex object, they are then free to use that protected resource. If another thread tries to lock the same mutex in the meantime, that second thread will be effectively paused until the mutex is unlocked by the first one, thus stopping it from reading or writing to the shared resource. Here is an example where I use a mutex to control printing access to the console.

Global ConsoleAccess.l = CreateMutex()

Procedure DrawNumbers(ThreadNumber.l)
	LockMutex(ConsoleAccess)
		ConsoleLocate(ThreadNumber * 20, 0)
		ConsoleColor((ThreadNumber + 1) * 3, 0)
		Print("Thread " + Str(ThreadNumber) + " locked.")
		For x.l = 1 To 20
			ConsoleLocate(ThreadNumber * 20, x + 1)
			Print(Str(x))
			Delay(75)
		Next x
	UnlockMutex(ConsoleAccess)
EndProcedure

If OpenConsole()
	EnableGraphicalConsole(#True)
	Thread0.l = CreateThread(@DrawNumbers(), 0)
	Thread1.l = CreateThread(@DrawNumbers(), 1)
	Thread2.l = CreateThread(@DrawNumbers(), 2)
	WaitThread(Thread0)
	WaitThread(Thread1)
	WaitThread(Thread2)
	ConsoleLocate(0, 23)
	Print("Press Return to quit") : Input()
	CloseConsole()
EndIf
End

When this code is run, numbers will be printed to the console by each thread, but because I’ve used a mutex in the ‘DrawNumbers()’ procedure only one thread at a time can lock the mutex and continue to print to the console.

The first line of code creates a new mutex object, this is done with the ‘CreateMutex()’ command (Helpfile:Reference Manual->General Libraries->Thread->CreateMutex). This command doesn’t require any parameters but when used will return a handle to a newly created mutex object. The returned handle is a 32 bit numeric value, so I’ve stored it in a Long type variable called ‘ConsoleAccess’.

Once the mutex object is created, I then need to make my thread procedures obey its status if it becomes locked or unlocked. To do this I need to add the lock and unlock commands to all thread procedures that are going to use this shared resource. In my example I have only one thread procedure, so I need to add this functionality there. If I were to add more thread procedures that printed to the console, I would have to code them to obey this mutex status too.

In order for a thread to be able to acquire a lock on a mutex object we use the ‘LockMutex()’ command (Helpfile:Reference Manual->General Libraries->Thread->LockMutex). This command takes one parameter which is the mutex handle of the mutex object we want to lock. If the mutex is currently unlocked, the ‘LockMutex()’ command will lock it and continue as normal. If, however, the mutex has already been locked by another thread, the ‘LockMutex()’ command will pause the thread until it is able to lock it itself, which would be after the other thread has unlocked it.

You can see this in action in my mutex example, I lock the mutex before I print to the console and then unlock it when I have finished, allowing other threads to lock it and continue printing. Unlocking the mutex object is as simple as calling the ‘UnlockMutex()’ command (Helpfile:Reference Manual->General Libraries->Thread->UnlockMutex) while passing a mutex handle as a parameter of the mutex object you want to unlock.

Continuing Your Thread If A Mutex Is Locked
Sometimes when your thread uses a shared resource protected by a mutex, it may be useful for it to not halt entirely when it cant lock an already locked mutex object. You may need your thread to continue doing something else, or provide feedback on the mutex status itself. If this is the case you can use the ‘TryLockMutex()’ command (Helpfile:Reference Manual->General Libraries->Thread->TryLockMutex). The ‘TryLockMutex()’ command does what it says on the tin, it tries to lock the mutex specified in the first parameter. If it fails because another thread has already locked the specified mutex, this command will return ‘0’ (zero). If, however, it is able to lock it, then this command will return a non zero value (meaning a numeric value other than zero).

Here’s an example that shows three threads, all trying to lock the ‘Lock’ mutex object using the ‘TryLockMutex()’ command. If any of them fail to do so then instead of just sitting idle and waiting until it’s unlocked, they display the amount of time they have been waiting in the relevant String gadget.

Enumeration
	#WINDOW_ROOT
	#TEXT_ONE
	#TEXT_TWO
	#TEXT_THREE
	#BUTTON_START
EndEnumeration
Global Lock.l = CreateMutex()

Procedure Update(Gadget.l)
	StartTime.l = ElapsedMilliseconds()
	Repeat
		If TryLockMutex(Lock)
			For x.l = 1 To 20
				SetGadgetText(Gadget, Str(Gadget) + " has locked the mutex. " + Str(x))
				Delay(250)
			Next x
			UnlockMutex(Lock)
			Break
		Else
			Time.s = "(" + Str((ElapsedMilliseconds() - StartTime) / 1000) + " Secs)"
			SetGadgetText(Gadget, Str(Gadget) + " is waiting for mutex. " + Time)
			Delay(1)
		EndIf
	ForEver
	SetGadgetText(Gadget, Str(Gadget) + " has finished.")
EndProcedure

#FLAGS = #PB_Window_SystemMenu | #PB_Window_ScreenCentered
If OpenWindow(#WINDOW_ROOT, 0, 0, 290, 130, "'TryLockMutex()' Test", #FLAGS)
	If CreateGadgetList(WindowID(#WINDOW_ROOT))
		StringGadget(#TEXT_ONE, 10, 10, 270, 20, "")
		StringGadget(#TEXT_TWO, 10, 40, 270, 20, "")
		StringGadget(#TEXT_THREE, 10, 70, 270, 20, "")
		ButtonGadget(#BUTTON_START, 95, 100, 100, 20, "Start")
		Repeat
			EventID.l = WaitWindowEvent()
			Select EventID
				Case #PB_Event_Gadget
					Select EventGadget()
						Case #BUTTON_START
							Thread1.l = CreateThread(@Update(), #TEXT_ONE)
							Thread2.l = CreateThread(@Update(), #TEXT_TWO)
							Thread2.l = CreateThread(@Update(), #TEXT_THREE)
					EndSelect
			EndSelect
		Until EventID = #PB_Event_CloseWindow
	EndIf
EndIf
End

Here you can see inside the thread procedure I’ve used a ‘Repeat’ loop to keep the thread active even if it can’t lock the mutex object. Once the mutex is locked, the thread counts to twenty, updating the String gadget as it goes. Once the count is finished the mutex is unlocked and the ‘Break’ keyword is used to exit the loop and ultimately end the thread. An ‘If’ statement is used to test the ‘TryLockMutex()’ command to decide which course of action is required depending on the status of the mutex.

In summary Threads are another useful tool in a programmer’s toolbox and like any tool need to be used correctly. When compiling any program that uses threads I would recommend that you always use the thread-safe compiler option and try to use as few threads as possible.

Also I would recommend that you thoroughly read through the entire ‘Thread’ section in the PureBasic helpfile (Helpfile:Reference Manual->General Libraries->Thread), as it lists many more useful thread commands than I have demonstrated in these pages. Before using threads you need to be completely aware of their uses and limitations.

Dynamic Link Libraries

Dynamic link libraries, also known as dynamically linked libraries and usually abbreviated to just ‘DLLs’, are Microsoft's implementation of a shared code library for the Microsoft Windows operating system, and as such are only available for use on Microsoft operating systems. DLLs enable programmers to compile code into a shared library to enable many computer programs to use the code contained within. Programs can dynamically connect to the DLL during runtime and use the library’s commands. When finished, the program can unload the library, freeing any memory associated with its use.

The DLL concept was one that was thought to decrease program filesize and memory requirements by storing libraries on the hard disk, then loading and using when needed. The reality however, especially prevalent in Microsoft Windows operating systems, is that many different versions of the same DLL are needed by different programs for compatibility reasons, meaning that sometimes many copies of the same DLL (albeit different versions) are required. This particular problem has been given the moniker ‘DLL Hell’, to imply the problems it can create.

Operating system problems aside, DLLs can be very useful to break a program into a modular approach. If you consider any code that you write to be useful for future programs, you can compile it into a DLL and then it will be available to any program that wants to use it.

PureBasic makes using DLLs simple by providing a built-in library of commands (Helpfile:Reference Manual->General Libraries->Library) to load and use DLLs, while the PureBasic compiler has an option to compile your code to a DLL, making PureBasic the perfect choice for using and creating DLLs.

Creating A DLL
When creating your own DLLs there are a few things you must do as a matter of course, but don’t worry they are quite painless. The first thing to remember when writing code to be used as a DLL is that nearly all your code must be written inside procedures. This is because, when a program loads your DLL, it runs the code contained within it by calling the compiled procedure names. Opening a library doesn’t automatically run the DLL like a program, instead, you have to call procedures from it. So what do I mean by nearly all code must be written like this? Well, variable and structure definitions don’t have to be written inside procedure definitions inside a DLL, but they are the only thing that doesn’t.

When writing code for DLLs there are four special reserved procedure names that are automatically called by Windows once the DLL is loaded. These four procedures are defined like any other DLL procedure but if they are named correctly, Windows will call each one when a particular condition arises surrounding the DLL. I personally define these in all DLLs I write, even if I don’t use them. This is so, if ever I need to go back to development of that particular DLL, they are always there ready to use if needed. Here is a list of the four reserved procedure names and what conditions automatically trigger their execution:

‘AttachProcess(Instance.l)’
This procedure is called once, when a program loads this DLL. This procedure is the only place in your code that you can define arrays and linked lists. I also use it to define variables and structures too, keeping everything in one place and not having anything outside procedures. The only limitation of this procedure is that DirectX initialization routines must not be written in here.

‘DetachProcess(Instance.l)’
This is called when the program closes this DLL. All clean-up code should be in here, such as freeing any resources used by this DLL.

‘AttachThread(Instance.l)’
This procedure is called each time a thread is created in the program that loads this DLL.

‘DetachThread(Instance.l)’
This procedure is called each time a thread exits in the program that loads this DLL.

As you can see from this list, they are not very complicated to understand and use simple names. If you want to use these automatically called procedures in your DLL, you just need to define the procedure names as shown. The ‘Instance’ parameter that all of these procedures create, is an instance handle (sometimes called a module handle). This can be handy for more advanced programming. This parameter always needs to be defined if you are using these procedures, even if you don’t intend on using the parameter in your code.

So now you know how a DLL should be coded (everything must be inside procedures) and you now know the names of the special reserved procedures, let me show you an example of a simple DLL.

ProcedureDLL AttachProcess(Instance.l)
	Global Message.s = "This is my DLL."
EndProcedure

ProcedureDLL ShowAlert()
	MessageRequester("Alert", Message)
EndProcedure

Here, I’ve not used all the special reserved procedures for the sake of brevity, the only one I’ve shown in this example is the ‘AttachProcess()’ procedure, within which I define a global String variable called ‘Message’. The second procedure in this example is called ‘ShowAlert()’. This will be the procedure I call when I open this DLL in another program. As you can see the message requester defined in the ‘ShowAlert()’ procedure uses the String that’s defined in the ‘AttachProcess()’ procedure.

You will also notice in this example that I’ve used a different keyword for defining these procedures, instead of ‘Procedure’ I’ve used ‘ProcedureDLL’. This is essential for defining the special reserved procedures and for any procedure you want to be available for other programs to use. You can still use the standard ‘Procedure’ keyword to define procedures, but these wont be accessible externally by other programs that load your DLL. These are mainly used for internal calculations, etc.

Once we have coded our DLL in the style above we need to test it. So first things first, let’s compile this example into a DLL. Because dynamic link libraries are a little bit different to standard programs, we need to tell the compiler to compile a DLL instead of a regular program. If your using the command line you can do this by using the ‘/DLL’ compiler option or if your using the IDE you can set it visually in the ‘Compiler Options’ dialog box (Menu:Compiler->Compiler Options...->Compiler Options->Executable Format->Shared DLL). Fig.52 shows where you need to select ‘Shared DLL’ within the ‘Compiler Options’ dialog box. Once this has been set you can select ‘Create Executable...’ in the ‘Compiler’ menu to actually produce the DLL. This allows you to specify a name and location for your DLL.

<<Fig 52>>

Once you have compiled your DLL, you will notice that the compiler creates three files. Say for example, we called our DLL, ‘Demo.dll’, you will end up with these three files:

‘Demo.dll’          ‘Demo.exp’          ‘Demo.lib’

The first one is of course the compiled DLL, the second is an export file and the third is a static library file. PureBasic only needs the DLL file to use the commands within, but the other files can be useful to people who use this DLL with other languages. If you are going to distribute your DLL file, I would recommend distributing all these files together, but if you are only using your DLL for use with PureBasic, you only need the DLL file and the other two can be discarded.

Using A DLL In Your Code
Using a DLL in a program is easy, you simply open the library and call the procedure you want to run. This is handled in PureBasic by using the commands from the ‘Library’ section (Helpfile:Reference Manual->General Libraries->Library). Here is an example of how we would call the ‘ShowAlert()’ procedure from the ‘Demo.dll’. Make sure you put the ‘Demo.dll’ in the same folder as the source code file that contains this code:

#LIBRARY_DEMO = 0
If OpenLibrary(#LIBRARY_DEMO, "Demo.dll")
	CallFunction(#LIBRARY_DEMO, "ShowAlert")
	CloseLibrary(#LIBRARY_DEMO)
EndIf

First, you open the library using the ‘OpenLibrary()’ command. This takes two parameters, the first is the PB number you want to associate to this newly opened library and the second is the name of the DLL you want to open. To call a function from within the opened DLL you use the ‘CallFunction()’ command, which takes two mandatory parameters. The first of which is the PB number of the library that you want to call a procedure from and the second is the name of the procedure you want to call. Notice that when you specify the name of the procedure to call, you don’t need to include the brackets on the end. After these two mandatory parameters, the ‘CallFunction()’ command can take up to twenty (20) optional parameters to pass values as parameters to the called DLL procedure. This is useful if the DLL procedure you are calling needs parameters to be passed. The last command I’ve used in this example is the ‘CloseLibrary()’ command, which closes the DLL associated with the PB number passed within its single parameter.

Creating and using DLLs can get a little more complicated than this, but the examples used here show the outline of the whole process. All DLLs consist of procedures and to use them, you just need to open the library and call them (using whatever method), it’s that simple.

When using a DLL like this you may be tempted to open the DLL, use a procedure and then immediately close the library. While this is fine for the odd one or two procedures to be called, you may run into performance issues if your program uses the DLL a lot. A better way to do things is that when your program initially starts up, open the DLL ready for use. Then in your program use the DLL procedures when needed. Then, when your program shuts down, close the DLL library along with it. This ensures that the DLL is only opened once and closed only once, removing any performance issues associated with these file operations.

Returning Values From DLL Procedures
When using procedures contained within DLLs, it may sometimes be necessary to return a value from one of them. You can do this by using the ‘ProcedureReturn’ keyword as you would in any ordinary procedure. Here is a simple example of a DLL procedure coded to return a result.

ProcedureDLL.l MultiplyValues(x.l, y.l)
	ProcedureReturn x * y
EndProcedure

As you can see it’s pretty straightforward and apart from the ‘ProcedureDLL’ keyword, it looks like any other normal procedure. Compile this piece of code into a DLL and then call it using this code:

#LIBRARY = 0
If OpenLibrary(#LIBRARY, "Demo.dll")
	ReturnValue.l = CallFunction(#LIBRARY, "MultiplyValues", 22, 33)
	Debug ReturnValue
	CloseLibrary(#LIBRARY)
EndIf

Here, I’m using the ‘CallFunction()’ command again but this time I’m using two of the optional parameters to pass values to the ‘MultiplyValues’ DLL procedure. The values I’m passing are ‘22’ and ‘33’. When these two are passed to the ‘MultiplyValues’ DLL procedure, it uses them as parameters and processes them accordingly. In this case, it multiplies them together and returns the result. The returned value is then passed back to the ‘CallFunction()’ command which returns it into our program. I’ve used a Long type variable called ‘ReturnValue’ to hold the returned value from the DLL procedure, which I then echo to the Debug Output window.

While this way of returning values is fine for most built-in integer types (see Limitations When Working With DLLs overleaf), for Strings it’s a little bit different. For a start, any Strings that you need to return from a DLL must be defined as global. This is to preserve the String after the DLL procedure has returned. Also, when a String is supposed to be returned from a DLL procedure, a memory address for the String is actually returned instead, even if the return type was defined as a String in the procedure definition.

Here’s an example to demonstrate this:

ProcedureDLL AttachProcess(Instance.l)
	Global MyString.s = "Lorem ipsum dolor sit amet."
EndProcedure

ProcedureDLL.s GetString()
	ProcedureReturn MyString
EndProcedure

In this example, I’ve defined the ‘GetString()’ procedure to return a String and made sure the ‘MyString’ variable is global. Try compiling this to a DLL and call it using this code:

#LIBRARY = 0
If OpenLibrary(#LIBRARY, "Demo.dll")
	*ReturnValue = CallFunction(#LIBRARY, "GetString")
	Debug PeekS(*ReturnValue)
	CloseLibrary(#LIBRARY)
EndIf

You’ll see that the ‘CallFunction()’ command returns a Long type number, so we have to use a numerical variable to hold it. So, I’ve created a pointer called ‘*ReturnValue’ to hold the returned memory address, from which, I read the String pointed to using the ‘PeekS()’ command.

Limitations When Working With DLLs
The only real limitations that exist when using DLLs is the passing and returning of values to and from the DLL. Bytes, Words and Longs are relatively painless to use and all DLL commands support them but for the other types there can be a bit of a headache. You’ve already seen the peculiarity of Strings returned as a memory address instead of the actual String itself. While Floats seem to get completely mangled when being returned from the DLL. Quads and Doubles are completely unsupported using the standard ‘Library’ commands but can be handled by using PureBasic prototypes which are a little beyond the scope of this book.

To handle returning a Float from a DLL procedure your best bet is to return its memory address instead and then read the returned value using ‘PeekF()’. Here is a little example of how to successfully return a Float from a DLL procedure. First, here is the example DLL:

ProcedureDLL AttachProcess(Instance.l)
	Global MyFloat.f = 3.1415927
EndProcedure

ProcedureDLL.l GetPi()
	ProcedureReturn @MyFloat
EndProcedure

Instead of returning the actual Float value, the DLL procedure ‘GetPi()’ is defined to return a Long. This allows me to return the Float’s memory address. Once this is compiled into a DLL I can call it using this code:

#LIBRARY = 0
If OpenLibrary(#LIBRARY, "Demo.dll")
	*ReturnValue = CallFunction(#LIBRARY, "GetPi")
	Debug PeekF(*ReturnValue)
	CloseLibrary(#LIBRARY)
EndIf

The memory address, once returned, gets assigned to the ‘*ReturnValue’ pointer, then I use the ‘PeekF()’ command to read the Float value pointed to in memory. In fact this trick of returning memory addresses can be used in a similar fashion to return memory address to Quads and Doubles, so in effect you can say PureBasic supports returning them. There is just no way at the minute of passing Quads or Doubles to DLL procedures as parameters using the ‘Library’ commands.

Using DLLs is quite simple once you’ve got your head around passing variables to the DLL and how you return and use the returned values. They can make code re-usable by coding it into a neatly packaged library. There are a few issues regarding some built-in types but these can be overcome by using more advanced methods, usually by just returning a pointer to what data you need returned. The more complicated approaches, such as prototypes are unfortunately a little too advanced to be going into at this stage, but you can always look them up in the PureBasic helpfile (Helpfile:Reference Manual->Prototype) to familiarize yourself with them just incase. Just don’t be shocked if you can’t understand them in your first go. It’s also worth reading the whole ‘Library’ section (Helpfile:Reference Manual->General Libraries->Library) in the PureBasic helpfile to learn about all the commands that can be used with DLLs. This should give you a good understanding of what’s available when you decide to develop your first real DLL.

<<Box 28>>

The Windows Application Programming Interface

You are probably wondering why I’m including a section on Windows programming in a book describing a computer language which is cross-platform. Well, I’m including it here because the Windows version of PureBasic has a rather cool and useful ability to be able to use the Windows Application Programming Interface natively. Let me explain a little more fully.

The Windows Application Programming Interface (Usually shortened to just the Win32 API) is found in all new versions of the Microsoft Windows operating system and is a common interface available for all computer programs to use. The Win32 API is basically a command library, contained within many different DLLs installed by default during a normal Windows installation. The API itself is part of the operating system and available to be used by any computer program to carry out almost anything that the operating system is capable of, e.g. opening windows, manipulating Strings, drawing shapes, etc.

Using Win32 API Commands
To use a Win32 API command, a user can simply load the DLL that contains the needed command and then call it, passing any relevant parameters that are needed. This can be done easily in PureBasic using the ‘Library’ commands but because PureBasic for Windows supports the Win32 API natively, you can use the API as easily as you would any other PureBasic command. For example, other more cumbersome programming languages would have to do things this way to display a simple message requester using the Win32 API:

#LIBRARY = 0
If OpenLibrary(#LIBRARY, "User32.dll")
	MB_OK = 0
	Caption.s = "Test"
	TextString.s = "This is a Win32 API Test"
	CallFunction(#LIBRARY, "MessageBoxA", #Null, @TextString, @Caption, MB_OK)
	CloseLibrary(#LIBRARY)
EndIf

As you can see, you would have to open the DLL where the required command resides, Here, it’s a command called ‘MessageBoxA’ located in ‘User32.dll’. Once this is open, you can call the necessary command passing any parameters needed. This is all well and good, but it’s a bit complicated and long winded. In PureBasic you can use that same command like this:

MessageBox_(#Null, "This is a Win32 API Test", "Test", #MB_OK)

Notice the underscore (‘_’) after the command name? That denotes that this is an API command and calls it from the necessary DLL automatically. I think you’ll agree, this way is a lot simpler and quicker to use. We are using the Win32 API command as if it were another native command in the standard PureBasic package.

The underscore can be used to automatically include any command from the Win32 API. For example, there is a command called ‘CharUpper’ in the Win32 API for converting Strings to uppercase, we can use this command as if it’s a native PureBasic command by using an underscore after it’s name and before the brackets, like this:

TextString.s = "this is all lowercase text."
CharUpper_(@TextString)
Debug TextString

This command needs a memory address of a String as a parameter according to the Win32 API documentation, so that’s what I’ve passed. When you run this example and look in the Debug Output window, you will see the text String has now been converted to uppercase. 

Using the Win32 API like this alleviates all the hassle of opening the required DLLs yourself and allows you to use an API command whenever you need to in your code. In fact if your using the Windows version of PureBasic you can mix regular and API commands as much as you like in your source code.

Using Win32 API Constants And Structures
To complement the ease of use of Win32 API commands in the Windows version of PureBasic, all the associated constants and structures have also been predefined. This means that if you ever need a constant or a structure to use with a Win32 API command, they have already been defined internally ready for immediate use.

You can see this in the PureBasic version of the ‘MessageBox’ command example on the other page, where I’ve used the constant ‘#MB_OK’ without defining it. This is because the Win32 API constant ‘MB_OK’ has already been defined internally. To use any Win32 API constant in PureBasic, you just need to add the hash symbol (‘#’) to the beginning of the Win32 API constant name and it should then be useable as if it was defined natively in your source code.

Win32 API Constant:  ‘MB_OK’
PureBasic’s version:  ‘#MB_OK’  (This doesn’t need defining, because it already has been internally.)

The same goes for Win32 API structures, whenever you need to use one, you just use it. There is no need to define it. Take a look at this example:

DesktopInfo.RECT
DesktopHandle.l = GetDesktopWindow_()
GetClientRect_(DesktopHandle, @DesktopInfo)

DesktopSize.s = "Your current desktop size is: "
DesktopSize + Str(DesktopInfo\right) + " x "
DesktopSize + Str(DesktopInfo\bottom)
Debug DesktopSize

Here, I’m using the Win32 API structure called ‘RECT’ without defining it and then I go on to use the Win32 API commands, ‘GetDesktopWindow’ and ‘GetClientRect’ as if they were native commands (notice the underscores?). As you can see from the ‘RECT’ structure, all Win32 API structures have been defined using uppercase names. This is the standard form when programming using the Win32 API and my naming preference for structures, as described in Chapter 8 (My Coding Format). 

This naming convention matches exactly the way in which structures are defined in the Win32 API reference manuals and to avoid confusion when it comes to use them.

For example, if the Win32 API documentation says that a particular command needs a variable defined with the structure ‘RECT’, then you can just use ‘RECT’ in your PureBasic source code as a structure.

Take this example text from the Win32 API documentation, detailing the ‘BeginPaint’ API command:

The BeginPaint function prepares the specified window for painting and fills a PAINTSTRUCT structure with information about the painting. 

HDC BeginPaint(
    HWND hwnd,	// handle to window
    PAINTSTRUCT lpPaint	// pointer to structure for paint information);	

Parameters

	hwnd
		Identifies the window to be repainted. 

	lpPaint
		Pointer to the PAINTSTRUCT structure that will receive painting information.

Return Values
	If the function succeeds, the return value is the handle to a display device
	context (HDC) for the specified window. If the function fails, the return
	value is NULL, indicating that no display device context is available.

You can see that this command needs a pointer (or memory address) to a structured variable as the second parameter, and this structured variable must be created from the ‘PAINTSTRUCT’ structure. To create such a variable in PureBasic we can do this:

PaintVariable.PAINTSTRUCT

And that’s it. The ‘PAINTSTRUCT’ structure has already been defined internally, so we can just use it without a definition. A full usage example of this command might look like this inside your main code:

...
PaintVariable.PAINTSTRUCT
WindowHandle.l = WindowID(#MY_WINDOW)
HDC.l = BeginPaint_(WindowHandle, @PaintVariable)
...

Viewing Internally Defined Constants And Structures
So now you know that a lot of handy data has been defined internally but you don’t necessarily know what exactly has been defined. To clear up any confusion and let you see what exactly has been defined the PureBasic IDE has a handy viewer for looking up all such data. This tool is called the ‘Structure Viewer’ and can be found in the ‘Tools’ menu in the IDE (Menu:Tools->Structure Viewer). Fig.53 shows the Structure Viewer as it appears on the Window operating system and notes many of the features that make this such an useful tool.

Once the Structure Viewer is open, you are greeted with a list of all structures that have been defined internally. This list can be searched and filtered alphabetically by using the appropriate control detailed in the diagram. Although this list initially shows defined structures, this can be changed by selecting a different tab to display defined interfaces or constants. Although interfaces haven’t been discussed in this book, the constants list will be helpful to you as this shows all internally defined constants and their values. All built-in PureBasic constants are shown here too.

To view the actual definitions of internally defined structures you just double-click their names in the data list. When you do this the ‘Insert Copy’ and ‘Insert’ buttons become active. The ‘Insert Copy’ button inserts a copy of the structure definition into your PureBasic source, while the ‘Insert’ button inserts code to actually use and define the fields within the structure. Open a new PureBasic source file and have a play to get used to how it works.

<<Fig 53>>

Documentation On The Win32 API
When using the Win32 API you are going to need a good reference documentation to understand what commands are available for use and to understand how to use them. The first port of call would probably be Microsoft’s Developers Network on the Internet (www.msdn.com) but this can be confusing for new users as the site is massive and contains information on every conceivable aspect of Windows programming, so it can be a pain to navigate. I’ve found the best solution (for me personally), is to consult a smaller more focused reference and then search the MSDN if more information is needed about a particular command or syntax.

The smaller reference I use is the ‘Win32.hlp’ file, a Windows helpfile that contains a reference for the Win32 API commands. This helpfile is not part of the normal PureBasic package so you will have to hunt it down and install it yourself, to be helpful I’ve provided an Internet link in Appendix A (Useful Internet Links). Once you have the ‘Win32.hlp’ file you should install it manually into the ‘Help’ folder which is inside your PureBasic folder. If a ‘Help’ folder doesn’t appear inside your PureBasic folder then just create one and place the ‘Win32.hlp’ file(s) inside that newly created folder. Sometimes the helpfile is accompanied with other files such as ‘Win32.cnt’ and ‘Win32.kwf’, if this is the case all must be installed together. Once this has been done, you can then take advantage of the integration between this file and the IDE.

Once this file is correctly installed, you can select any Win32 API command within the IDE by placing your cursor within it and then hitting ‘F1’. Now, instead of the usual PureBasic helpfile appearing, the ‘Win32.hlp’ file is opened on the correct page for the highlighted Win32 API command. This behavior doesn’t stop the standard PureBasic helpfile from functioning, it just opens a different helpfile depending on what command is highlighted within the IDE.

Try it for yourself, type this code in from a previous example, place the flashing text cursor within the ‘GetClientRect’ command and hit ‘F1’.

DesktopInfo.RECT
DesktopHandle.l = GetDesktopWindow_()
GetClientRect_(DesktopHandle, @DesktopInfo)

DesktopSize.s = "Your current desktop size is: "
DesktopSize + Str(DesktopInfo\right) + " x "
DesktopSize + Str(DesktopInfo\bottom)
Debug DesktopSize

You should now see the ‘Win32.hlp’ file opened and displaying the page on the ‘GetClientRect’ command. Don’t forget, the ‘Win32.hlp’ file is a standard Windows helpfile and as such is easily navigated and fully searchable, so it’s maybe worth a read at some point if you plan on doing a lot of Win32 API programming.

Disadvantages Of Using The Win32 API In PureBasic
One of the biggest disadvantages of using the Win32 API in a PureBasic program is that you can only use these commands on a Microsoft Windows operating system. This means that any program you write using these commands will only be able to be compiled using PureBasic for Windows.

Another big disadvantage is that the Win32 API was originally designed to be used by the C and C++ programming languages and as such contains references to many advanced data types that simply don’t exist in PureBasic. For the most part however, you can substitute a PureBasic type in place of a C/C++ type. Fig.54 shows a diagram of what PureBasic types can be used instead of the C/C++ types listed. For example, if you read in a Win32 API command description that a particular command needs a variable of type ‘DWORD32’, looking at Fig.54 you can see that you can use a PureBasic Long type instead.

<<Fig 54>>

You will notice that some types listed in Fig.54 are marked with a ‘†’ symbol. This is to show that these types do not exactly match their PureBasic counterparts. The reason for this mismatch is that all the marked Win32 API types are unsigned (except for ‘TBYTE’) while the substitute PureBasic types are all signed. Because of this, some types might suffer from numerical wrapping issues. The odd one out is the API type: ‘TBYTE’, which is signed while the PureBasic Character type which substitutes it, is unsigned. This ultimately shouldn’t raise massive problems in your program, because with a little bit of coding you can easily convert signed values to unsigned values and vice versa. Here are a few procedures that you could use to convert all these problem types:

;Returns the correct unsigned value from a UCHAR.
Procedure.w UCHAR(UCHAR.b)
	ProcedureReturn UCHAR & $FF
EndProcedure

;Returns the correct signed value from a TBYTE.
CompilerIf #PB_Compiler_Unicode
	Procedure.w TBYTE(TBYTE.c)
CompilerElse
	Procedure.b TBYTE(TBYTE.c)
CompilerEndIf
	ProcedureReturn TBYTE
EndProcedure

;Returns the correct unsigned value from a USHORT.
Procedure.l USHORT(USHORT.w)
	ProcedureReturn USHORT & $FFFF
EndProcedure

;Returns the correct unsigned value from a UINT.
Procedure.q UINT(UINT.l)
	ProcedureReturn UINT & $FFFFFFFF
EndProcedure

;Returns the correct unsigned value from a UINT32.
Procedure.q UINT32(UINT32.l)
	ProcedureReturn UINT32 & $FFFFFFFF
EndProcedure

;Returns the correct unsigned value from a ULONG.
Procedure.q ULONG(ULONG.l)
	ProcedureReturn ULONG & $FFFFFFFF
EndProcedure

;Returns the correct unsigned value from a ULONG32.
Procedure.q ULONG32(ULONG32.l)
	ProcedureReturn ULONG32 & $FFFFFFFF
EndProcedure

For example, if you used a PureBasic Byte (which is signed) to store a ‘UCHAR’ unsigned value, then you can only read that unsigned value correctly by using the ‘UCHAR()’ procedure like this:

MyUCHAR.b = 255 ; This represents '-1' signed and '255' unsigned.
Debug MyUCHAR ; This echoes the signed value of '-1'.
UnsignedValue.w = UCHAR(MyUCHAR)
Debug UnsignedValue ; This echoes the unsigned value of '255'.

The only drawback in using these procedures is that the value they return, (although totally correct) uses twice the amount of memory of the type you passed as a parameter. Just look at the ‘UCHAR()’ procedure in the last example. This accepts a Byte as a parameter of the ‘UCHAR’ you want to read, and then returns a Word containing the correct unsigned value. That’s double the size of the original Byte. This is done because nearly all PureBasic’s types are signed, so we have to use a big enough type to correctly express an unsigned value, avoiding any wrapping issues.

Assigning unsigned values to signed types on the other hand is easy. As shown in the last example, you can assign an unsigned value to a signed type, but that value is always stored as a signed value. So, this line of code:

MyUCHAR.b = 255
Debug MyUCHAR

Would actually store ‘-1’ as its value. This is implemented in PureBasic to ease such Win32 API conversion issues.

A Quick Note Regarding Win32 API String Pointer Types
When using Win32 API String pointer types, it’s useful to know how to read and write to memory correctly for each of the different types of String they point to. For example, a pointer of type ‘LPCSTR’ would be used by the Win32 API to point to a one Byte per character ASCII String, while a pointer of type ‘LPCWSTR’ would point to a two Bytes per character unicode String. Even though all String pointers use a PureBasic Long type to represent the actual pointer and hold a memory location, you have to peek and poke each one from memory using a different mode of the ‘PeekS()’ and ‘PokeS()’ commands to properly observe each String type’s character encoding.

Here are the Win32 API String pointer types, and more importantly, how to correctly read and write each type of String from the memory location they point to:

‘LPCSTR’
One Byte per character (ASCII) String, even if the program is compiled in unicode mode.

PeekS(StringPointer.l, StringLength, #PB_Ascii)
PokeS(StringPointer.l, Text.s, StringLength, #PB_Ascii)

‘LPCWSTR’   ‘PCWSTR’   ‘PWSTR’   ‘LPOLESTR’ 
Two Bytes per character (Unicode) String, even if the program isn’t compiled in unicode mode.

PeekS(StringPointer.l, StringLength, #PB_Unicode)
PokeS(StringPointer.l, Text.s, StringLength, #PB_Unicode)

‘LPCTSTR’   ‘LPTSTR’   ‘LPSTR’   ‘PCTSTR’   ‘PTSTR’
Exactly the same as a standard PureBasic String, which is one Byte per character if the program is not compiled in unicode mode and two Bytes per character if the program is compiled in unicode mode.

PeekS(StringPointer.l, StringLength)
PokeS(StringPointer.l, Text.s, StringLength)

A Doorway To A Larger World
Hopefully this brief introduction to the Win32 API will spur you on to read more about it and perhaps use it in your Windows programming. Sometimes when using PureBasic and writing software for Microsoft Windows, you may need the occasional API command to provide extra functionality that is not currently available natively in PureBasic.